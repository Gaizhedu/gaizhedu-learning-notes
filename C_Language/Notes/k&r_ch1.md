# 第一章
第一章主要通过华氏温度转换器来讲解例子

首先需要注意的一个点是这个
``` C
printf("%d\t%d\n",fahr，celsius);
```
这里可以等价Python中的
``` Python
print(f"{fahr} {celsius}")
```

每个百分号表示其他的参数，这里的话就是后面的两个参数`fahr`和`celsius`

而`\t`代表留一个制表符的位置

其他内容与Python没什么区别（例如while）

这就是一开始的代码，在之后我们会一点点完善：
``` C
#include <stdio.h>

main()
{
	int fahr, celsius;
	int lower, upper, step;

	lower = 0;
	upper = 300;
	step = 20;

	fahr = lower;
	while (fahr <= upper) {
		celsius = 5 * (fahr - 32) / 9;
		printf("%d\t%d\n", fahr, celsius);
		fahr += step;
	}

}
```

首先是第一个问题，我们在运行之后可以发现数据并不是右对齐的，所以不是很美观

这时候我们可以在`%d`中间加上数字来指定打印宽度

例如：
``` C
printf("%3d\t%6d\n", fahr, celsius);
printf("%3d\t%3d\n", fahr, celsius);
```
其输出如下：
``` C
  0        -17
  0     -17
150         65
150      65
300        148
300     148
```
可以看到，在指定打印宽度后，相对应的数据就会随之对齐，同时可以发现`%6d`会比`%3d`更宽

## 修改数据类型
由于温度是必定有小数的，不可能是整数，所以这里必须要用到另一个数据类型：**float（浮点数）**

具体的话只需要修改一开始的声明即可：
``` C
float fahr, celsius;
```

这时候如果运行的话，可以发现并不是很美观，因为每个数字都带上了很长一串小数，这时候便要用到另一个东西：格式化文本

具体可以如下操作：
``` C
printf("%3.1f\t%6.1f\n", fahr, celsius);
```

这里需要注意一点的是：`%d`指的是整型类型，而`%f`指的是浮点数类型

细心发现，这里比之前的文本多了个`.1`，这代表着精确到小数点后1位

还有一点，前文的程序中出现了这个运算式：

``` C
celsius = 5 * (fahr - 32) / 9;
```

这里不可以使用`5/9`这种形式

这是因为按整型除法的计算规则，这两个数相除并舍位后得到的结果为**0**

但由于这个时候我们已经将数据类型改为浮点数了，那么便不会出现舍位的情况

---
### 小拓展：为什么会出现整型舍位的情况
接下来来讲讲为什么上文不可以为5/9

首先需要明白的一点是，这两个数的数据类型为整型，所以除出来的结果**必定是一个整数**

而5/9的结果约为`0.55`，保留整数部分后为`0`

舍位，指的也就是舍掉某一位，这里是整型类型，所以必须舍掉小数部分

---

另外，如果某个算术运算符的所有操作数有整型和浮点数，那么在开始运算之前所有的整型数都会被转换成浮点数

比如说这里：
``` C
fahr - 32
```
这里的话`32`会被转换为浮点数（32.0）再参加运算

## For 循环语句
接下来介绍C语言里面的For 循环语句

其具体的框架如下：
``` C
for(第一个式子; 第二个式子; 第三个式子){
	表达式;
}
```
### 第一个式子
在`For语句`中，括号内第一个式子指的是初始化变量

例如：
``` C
for(fahr = 0; 第二个式子; 第三个式子){
	表达式;
}
```
需要注意的一点是这个式子可以省略，但必须保留分号：
``` C
for(; 第二个式子; 第三个式子){
	表达式;
}
```
但在这个时候初始化的工作就必须在`For`循环外面实现

### 第二个式子
第二个式子的作用是判断是否继续执行循环，如果为真（不为0），则继续执行

如果为假（0），则结束循环

例如：
``` C
for(; fahr <= 300; 第三个式子){
	表达式;
}
```

这个式子同样可以省略，但如果省略会导致无限循环，除非有`break`语句退出循环

与上面一样，如果省略同样需要保留分号

### 第三个式子
第三个式子指的是每次循环后执行的语句，一般用于更新循环变量的值

相应例子如下：
``` C
for( ; ; fahr += 1){
	表达式;
}
```
第三个式子与前面一样，可以省略不写，但如果不在循环体内更新变量的话，可能会导致无限循环

---
下面通过一个例子来说明具体的用法
``` C
for(fahr = 0; fahr <= 300; fahr += 150){
	printf("%3.1f\n", fahr);
}
```

首先这个循环先定义变量`fahr`为0，之后开始执行循环，每次循环打印一次`fahr`

同时在每次训话循环结束后，变量`fahr`的值增加150，直到`fahr`的值大于300的时候结束循环

---
## 符号常量
符号常量指的是将一个符号定义为一个字符串

例如，可以将300定义为`UPPER`

在C语言中，使用符号常量的办法是利用`#define`

具体操作方法如下：
``` C
#define 符号常量名称 要替换的文本
```

例如：
``` C
#define UPPER 300
```

利用这个小方法，我们之前的例子可以改写为：
``` C
#define LOWER 0
#define UPPER 300
#define STEP 150
int main() {
	float fahr;
		for (fahr = LOWER; fahr <= UPPER; fahr += STEP) {
			printf("%3.1f \t %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
		}
}
```

相较于之前的直接在`main()`里面定义变量，这种方法会更加直观（前提是你的符号常量是明确的，无歧义的）

另外，细心的人可能发现了，用`#define`定义符号常量的时候并不需要在末尾加分号

还需要注意一点的是，符号常量的名字一般来讲是大写，为了与其他用小写的变量名作区分

### 拓展内容
以下内容K&R书中在第一章未提及

**#define 的本质**
#define 的本质为文本替换，也就是说在编译前的**预处理**阶段，会把整个程序里面出现的符号变量的名字（不包括在引号里面的）替换为替换文本的东西

以上面的例子为例，在预处理阶段会扫一遍有没有单独出现的`UPPER`，如果有，就替换为`300`

---
## 文件复制
接下来来讲讲文件复制

在这里需要用到两个全新的函数`getchar()`和`putchar()`

其中`getchar()`为获取输入，例如：
``` C
c = getchar();
```

此时变量`c`就被赋予了对应的输入内容

接下来是`putchar()`，作用为输出括号内的内容，例如：
``` C
putchar(c);
```

这样就输出了变量`c`的内容

接下来通过一个具体的例子来说明一下使用的方法：

``` C
#include <stdio.h>
int main(){
	int c;

	c = getchar();
	while(c != EOF){
		putchar(c);
		c = getchar();
	}
}
```

通过上面的代码，我们便实现了一个输出的内容为输入的内容的小工具

相当于复制后自动输出的效果

这里要说明一下，`EOF`指的是`end of file`，通过按`Ctrl+Z`后回车即可触发

当然，还可以把上面的这个写的更加紧凑一点：
``` C
#include <stdio.h>
int main(){
	int c;

	;
	while((c = getchar()) != EOF){
		putchar(c);
	}
}
```
接下来讲解一下

首先循环第一步，请求输入，并把输入的内容赋值给`变量c`，而后开始判断，如果`变量c`不为`EOF`，则继续执行，否则直接结束循环

这里要特别注意的一点是，`while`括号内必须这样写，才可以正常识别

这是由于在C语言中，不等于运算符!=的优先度是大于赋值运算符的=，正因如此，如果没加括号，则会变成这样子：

## 文件复制
接下来来讲讲文件复制

在这里需要用到两个全新的函数`getchar()`和`putchar()`

其中`getchar()`为获取输入，例如：
``` C
c = getchar();
```

此时变量`c`就被赋予了对应的输入内容

接下来是`putchar()`，作用为输出括号内的内容，例如：
``` C
putchar(c);
```

这样就输出了变量`c`的内容

接下来通过一个具体的例子来说明一下使用的方法：

``` C
#include <stdio.h>
int main(){
	int c;

	c = getchar();
	while(c != EOF){
		putchar(c);
		c = getchar();
	}
}
```

通过上面的代码，我们便实现了一个输出的内容为输入的内容的小工具

相当于复制后自动输出的效果

这里要说明一下，`EOF`指的是`end of file`，通过按`Ctrl+Z`后回车即可触发

当然，还可以把上面的这个写的更加紧凑一点：
``` C
#include <stdio.h>
int main(){
	int c;

	while((c = getchar()) != EOF){
		putchar(c);
	}
}
```
接下来讲解一下

首先循环第一步，请求输入，并把输入的内容赋值给`变量c`，而后开始判断，如果`变量c`不为`EOF`，则继续执行，否则直接结束循环

这里要特别注意的一点是，`while`括号内必须这样写，才可以正常识别

这是由于在C语言中，不等于运算符!=的优先度是大于赋值运算符的=，正因如此，如果没加括号，则会变成这样子：
``` C
#include <stdio.h>
int main() {
	int c;

	while (c = (getchar() != EOF)) {
		printf("%d",c);
	}
}
```

这样就变成了先判断输入的数是不是EOF，如果不是，赋值`变量c`为1，如果是的话则赋值为0

这样就变成了先判断输入的数是不是EOF，此时返回的结果为一个布尔值，**True为1，False为0**

此时变量c的结果只有**1或0**

需要注意的一点是，这里使用的类型为`int`，而不是`char`

这是因为`EOF`的值为`-1`，超出了`char`的范围（0~255）

当然，也有一种情况`char`的范围为（-128~127），但在这种情况，有些字符会被判断为负值（例如扩展 ASCII 码的128~255），这个时候便会与`EOF`混淆

### 拓展内容
如果你试着执行上面括号不对的版本并输入

你会发现输出的内容并不是一个单独的1

这是因为你输入的内容都会进行一次判断，每次判断都会输出相应的内容

比如你输入`123`，那么会以此判断`1`和`2`和`3`

这时候就又会发现，诶，输出怎么是4个1，这是因为你输入的时候还需要回车，回车是换行符`\n`，也需要进行一次判断，这就导致了有4个1

## 字符计数
接下来学习一个新的运算符`++`

这个运算符的作用是使得这个变量加一，具体效果如下：
``` C
++nc;
```

此时nc的值会加一

那么有什么作用呢，接下来通过一个例子来说明

``` C
#include <stdio.h>

int main(){
	long nc;

	nc += 0;
	while(getchar() != EOF){
		++nc;
	}
	printf("%ld",nc);
}
```

这段代码的大意为：每次执行循环若不为`EOF`，则变量`nc`的值加一

输入为`EOF`的时候，退出循环，并且打印`nc`的值

这里还有一个需要补充的点

可以看到这里有一个新的数据类型：`long`

这个类型的特点如下：

在一些机器上`int`和`long`的长度相同，但在一些机器上，`int`类型长度只有16位的存储单元的长度(最大值为32767)

而`long`类型的存储单元长度有**32位**(差不多21亿)，这就可以避免了输入过多导致报错的情况

对应的格式为`%ld`

此外还有另外一个数据类型：`double`可以储存的长度为**64位**

``` C
#include <stdio.h>

int main() {
	double nc;

	for (nc = 0; getchar() != EOF; nc++)
		;
	printf("%.0f\n", nc);
}
```
在这个语句中，for的循环体是空的，但由于C语言的语法规则要求必须有一个循环体，所以这里用一个单独的分号来表示

像这样的单独一个分号被称为**空语句**

这里需要说明的一点是，`while语句`和`for语句`的一大有点就是在执行循环体之前就会对条件进行测试

如果条件不满足，则不会执行循环体

## 行计数
接下来来讲讲行计数，这里对应原文的1.5.3的内容

首先，为了实现行计数，我们需要用到前文提及到的几个点

- 第一 `while`语句的检测是一个字符一个字符的检测
- 第二 换行符`\n`虽然看不到输入，但也是实际存在的

利用这几个点，便可以写出一个行计数的小程序

接下来讲讲思路

首先第一个，要先大概明白要干什么，主体的思路大概为检测输入的内容，如果出现了换行符，则次数加一，直到结束输出次数

具体代码如下：
``` C
int main() {
	int c, nl;

	nl = 0;
	while ((c = getchar()) != EOF)
		if (c == '\n')
			++nl;
	printf("%d\n", nl);
}
```

这里的`(c == '\n')`需要注意的是必须为**单引号**，这是因为在C语言中这两者的作用并不相同（不跟Python一样）

单引号表示字符常量，用于表示单个字符，一般用于给`char`变量赋值：

``` C
char c = 'A';
```

而双引号则表示一串字符（实际上为一个以`\0`结尾的字符数组），一般用于定义字符串

这里要表示的是换行符`\n`，而不是这个字符串`\n`，所以应该用单引号

## 单词计数
接下来讲讲单词计数的内容

这部分的内容主要计数分成了几个点

- 计数字符数
- 计数单词数
- 计数行数

首先讲解一下思路，由于字符是无论怎么样，只要有输入就算是有的，所以可以在每一次检测的时候加一即可

接下来是单词数，这里讲的单词指的是任何不包含**空格、制表符或换行符的字符序列**的字符

最后的行数，其实也就是指换行符的数量`\n`

这时候可能就有个大概的思路了

每次循环都加一（字符数），如果为换行符的话，则行数加一，如果不为空格、制表符等符号的话，则单词数加一

稍微思考一下便可以得出这个例子：

``` C
int main() {
	int c, n_word, n_line, n_chara,isword;

	isword = 1;
	n_word = n_line = n_chara = 0;
	while ((c = getchar()) != EOF) {
		++n_chara;
		if (c == ' ' || c == '\n' || c == '\t')
			isword = 0;
		if (isword)
			++n_word;
		else if (c == '\n')
		{
			++n_line;
			isword = 1;
		}
		else
		{
			isword = 1;
		}
	}
	printf("字符数：%d 单词数：%d 行数：%d", n_chara, n_word, n_line);
}
```

当然，也可以使用K&R里面的例子：
``` C
#define IN 1
#define OUT 0

int main() {
	int c, nl, ns, nw, state;

	nl = ns = nw = 0;
	state = OUT;
	while ((c = getchar()) != EOF) {
		++ns;
		if (c == '\n')
			++nl;
		if (c == ' ' || c == '\n' || c == '\t') {
			state = OUT;
		}
		else if (state == OUT)
		{
			state = IN;
			++nw;
		}
	}
	printf("单词数：%d 行数：%d 字符数：%d", ns, nl, nw);
}
```

## 数组
接下来来讲讲数组的内容，这里对应的是原文的1.6的部分

首先简单介绍一下数组，数组是一个可以储存变量的容器，你可以往里面填入值

格式如下：
``` C
ndigit[x] = y;
```
其中`x`为你要填入的位置（默认以0开始），`y`表示这个位置的值

利用这个特性，我们便可以用更聪明的方式来统计东西

首先我们需要明白一个点，在ASCII码中`0`~`9`是连一块的

而如果我们将基准定为输入的数字（例如`2`）

此时通过`2` - `0`，便可以得出位置`2`（对应数组里面的**3号位**）

那么这样的话，便可以到这样的代码：
``` C
for (i = 0; i < 10; ++i) {
	// 这里是初始化每个数字的次数
	ndigit[i] = 0;
}
while ((c = getchar()) != EOF) {
	if (c >= '0' && c <= '9') {
		++ndigit[c - '0'];
	}
}
```
首先第一个的`for语句`其作用为初始化每个数字出现的次数

而下一个`while语句`便是重点

首先循环体if语句的判定条件限定在了0~9，并且正如上面所讲的一样，判断内的部分为指定位置的值的增加（说白了就是增加次数到指定的位置上）

这样有什么好处呢，这样的话便不用自己去定义位置，使代码更为简洁

完整代码如下：
``` C
int main() {
	int c, i;
	int nwhite, nother;
	int ndigit[10];

	nwhite = nother = 0;
	for (i = 0; i < 10; ++i) {
		// 这里是初始化每个数字的次数
		ndigit[i] = 0;
	}
	while ((c = getchar()) != EOF) {
		if (c >= '0' && c <= '9') {
			++ndigit[c - '0'];
		}
		else if (c == ' ' || c == '\n' || c == '\t') {
			++nwhite;
		}
		else {
			++nother;
		}
	}
	printf("各个数字出现次数为：");
	for (i = 0; i < 10; ++i) {
		printf("%d", ndigit[i]);
	}
	printf("空格数：%d 其他字符：%d",nwhite,nother);
}
```
这里用else语句而不是在一开始就加1的原因是这里为**其他字符**，而不是**所有字符**

所以放到最后面来兜底

## 函数
接下来讲讲函数方面的内容，这里对应书中的1.7 函数

首先是一个简单的引入。在之前的例子中，我们有使用过这些内置的函数：`printf()`、`getrchar()`、`putchar()`

而这次的目的就是自己编写一个函数，并且成功调用这个函数

### 任务说明
在Python中，有一个运算符`**`其作用为进行幂计算

``` Python
print(x**y)
```
这里`变量x`代表底数，`变量y`代表幂，例如：

``` Python
print(2 ** 3)

# 输出：8（2的三次方）
```

而在C中，并没有类似的运算符，所以我们可以自己编写一个运算符

### 思路
首先幂的计算便是n个底数进行相乘，所以这里有个简单的方法就是利用for语句进行多次循环，最后返回计算好的结果

### 代码实现
通过上面的思路，可以比较轻松的写出下面这个函数，接下来开始逐一介绍

``` C
int power(int base, int n) {
	int i,p;

	p = 1;
	for (i = 1; i <= n; ++i) {
		p *= base;
	}
	return p;
}
```

首先我们可以模拟一下运算的流程，比如说2的3次方
```
第一次：2
第二次：4
第三次：8
```

这里其实有个很巧的点，如果n为0的话，那就是2的0次方了，根据`for语句`条件`i <= n`才会执行循环体内的内容

此时由于n为0，不满足循环条件，所以并不执行循环

但是很巧的一点是，**2的0次方恰好为1**

这也是设计的一个巧妙的点

---
接下来开始说明

首先函数`power`接受两个值：`base`和`n`

这里的话`base`作为底数，`n`作为幂

由于循环判断条件是`i <= n`，而循环体内的条件为每次循环都乘底数一遍，直到不循环为止

最后循环结束，输出对应的值

完整代码如下：
``` C
int main() {
	int power(int m, int n);

	printf("%d,%d", 2, power(2, 3));
}

int power(int base, int n) {
	int i, p;

	p = 1;
	for (i = 1; i <= n; ++i) {
		p *= base;
	}
	return p;
}
```

### 语法笔记
上面为K&R中提供的案例，接下来来讲讲K&R里面的笔记

#### 定义函数
接下来来讲讲定义函数的部分、

首先给出定义函数的结构：
``` C
返回的类型 函数的名字(声明参数)
{
	声明参数部分

	函数语句
}
```

需要注意的一点是，函数的定义可以在一个文件的任何地方，这跟Python是截然不同的（Python需要先定义才能调用，C可以把定义的部分放到最后面）

#### 函数的参数
每个函数声明的参数仅在这个函数内部生效，不影响其他函数

正因如此，其他函数便可以与之使用同样的参数名

通常把函数定义中出现的参数称为**形式参数**

而把函数调用中与形式参数对应的值称为**实际参数**

举个例子：
``` C
int main() {
	int power(int m, int n);

	printf("%d,%d", 2, power(2, 3));
}

int power(int base, int n) {
	int i, p;

	p = 1;
	for (i = 1; i <= n; ++i) {
		p *= base;
	}
	return p;
}
```
上面这个例子中，形式参数为`base`和`n`，实际参数为`2`和`3`

#### return语句
在调用了函数后，我们要怎么让结果输出出去呢，这时候便可以使用到`return`语句了

这个语句的效果是返回`return`后面的表达式，比如上面的例子就返回了`p`

---
如果你仔细观察的话，便可以发现`main`其实也是一个函数，但是这个函数可以省略`return`语句

而其他函数如果有指定返回值的类型但是没有给出返回值，则属于 **“未定义行为”**（返回的结果不可以预测）

这里的声明返回值类型指的是这里：
``` C
int main(){
	;
}
```
`main`前面的`int`便是指明了返回值的类型，

#### 函数原型
在作者的例子中还使用了`函数原型`
``` C
int power(int m, int n);

int main() {
	int i;

	for (i = 0; i < 10; ++i) {
		printf("%d %d %d\n", i, power(2, i), power(-3, i));
	}
	return 0;
}

int power(int base, int n) {
	int i, p;

	p = 1;
	for (i = 1; i <= n; ++i)
		p *= base;
	return p;
}
```
也就是上面这里例子中的`int power(int m, int n);`

这里表明了函数`power`有两个`int`类型的参数，并且返回一个`int`类型的值

特别需要注意的一点是，函数原型必须与函数的定义和用法一致，否则会出现报错

但函数原型和定义函数的参数名可以不相同，例如在上面这个例子中，函数原型的参数分别为`m`，`n`

而定义函数的时候为`base`和`n`

有趣的一点是，函数原型的参数名是可选的，也就是说你可以写成这样：
``` C
int power(int, int);
```

不过一般为了说明，不会省略参数名

## 参数——传值调用
接下来简单讲一下传参的问题

在C语言中，函数内部的所有参数值都是通过值传递的，传递的参数值都被传递到临时变量中，与原来的变量相隔开

正因如此，被调用的函数不能修改外部主调函数的变量值，只能修改自己函数内部的值

举个例子：
``` C
int power(int, int);

int main(){
	int c;
	
	c = getchar();
	printf("结果为：%d，幂为：%c\n", power(2, c),c);
	return 0;
}

int power(int base ,int n){
	int p;
	
	for (p = 1; n - '0' > 0; --n) {
		p *= base;
	}
	return p;
}
```
在上面这个例子中，`函数power`的参数由`c`决定，也就是函数内的`n`

这里可以看到，在执行函数后，原本作为参数传进去的`c`并没有在外部修改，仍然保持原有的值

当然，也可以让函数修改主调函数的变量，但需要用到指针，这里不展开说明