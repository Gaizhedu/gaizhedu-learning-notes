# 第一章
第一章主要通过华氏温度转换器来讲解例子

首先需要注意的一个点是这个
``` C
printf("%d\t%d\n",fahr，celsius);
```
这里可以等价Python中的
``` Python
print(f"{fahr} {celsius}")
```

每个百分号表示其他的参数，这里的话就是后面的两个参数`fahr`和`celsius`

而`\t`代表留一个制表符的位置

其他内容与Python没什么区别（例如while）

这就是一开始的代码，在之后我们会一点点完善：
``` C
#include <stdio.h>

main()
{
	int fahr, celsius;
	int lower, upper, step;

	lower = 0;
	upper = 300;
	step = 20;

	fahr = lower;
	while (fahr <= upper) {
		celsius = 5 * (fahr - 32) / 9;
		printf("%d\t%d\n", fahr, celsius);
		fahr += step;
	}

}
```

首先是第一个问题，我们在运行之后可以发现数据并不是右对齐的，所以不是很美观

这时候我们可以在`%d`中间加上数字来指定打印宽度

例如：
``` C
printf("%3d\t%6d\n", fahr, celsius);
printf("%3d\t%3d\n", fahr, celsius);
```
其输出如下：
``` C
  0        -17
  0     -17
150         65
150      65
300        148
300     148
```
可以看到，在指定打印宽度后，相对应的数据就会随之对齐，同时可以发现`%6d`会比`%3d`更宽

## 修改数据类型
由于温度是必定有小数的，不可能是整数，所以这里必须要用到另一个数据类型：**float（浮点数）**

具体的话只需要修改一开始的声明即可：
``` C
float fahr, celsius;
```

这时候如果运行的话，可以发现并不是很美观，因为每个数字都带上了很长一串小数，这时候便要用到另一个东西：格式化文本

具体可以如下操作：
``` C
printf("%3.1f\t%6.1f\n", fahr, celsius);
```

这里需要注意一点的是：`%d`指的是整型类型，而`%f`指的是浮点数类型

细心发现，这里比之前的文本多了个`.1`，这代表着精确到小数点后1位

还有一点，前文的程序中出现了这个运算式：

``` C
celsius = 5 * (fahr - 32) / 9;
```

这里不可以使用`5/9`这种形式

这是因为按整型除法的计算规则，这两个数相除并舍位后得到的结果为**0**

但由于这个时候我们已经将数据类型改为浮点数了，那么便不会出现舍位的情况

---
### 小拓展：为什么会出现整型舍位的情况
接下来来讲讲为什么上文不可以为5/9

首先需要明白的一点是，这两个数的数据类型为整型，所以除出来的结果**必定是一个整数**

而5/9的结果约为`0.55`，保留整数部分后为`0`

舍位，指的也就是舍掉某一位，这里是整型类型，所以必须舍掉小数部分

---

另外，如果某个算术运算符的所有操作数有整型和浮点数，那么在开始运算之前所有的整型数都会被转换成浮点数

比如说这里：
``` C
fahr - 32
```
这里的话`32`会被转换为浮点数（32.0）再参加运算

## For 循环语句
接下来介绍C语言里面的For 循环语句

其具体的框架如下：
``` C
for(第一个式子; 第二个式子; 第三个式子){
	表达式;
}
```
### 第一个式子
在`For语句`中，括号内第一个式子指的是初始化变量

例如：
``` C
for(fahr = 0; 第二个式子; 第三个式子){
	表达式;
}
```
需要注意的一点是这个式子可以省略，但必须保留分号：
``` C
for(; 第二个式子; 第三个式子){
	表达式;
}
```
但在这个时候初始化的工作就必须在`For`循环外面实现

### 第二个式子
第二个式子的作用是判断是否继续执行循环，如果为真（不为0），则继续执行

如果为假（0），则结束循环

例如：
``` C
for(; fahr <= 300; 第三个式子){
	表达式;
}
```

这个式子同样可以省略，但如果省略会导致无限循环，除非有`break`语句退出循环

与上面一样，如果省略同样需要保留分号

### 第三个式子
第三个式子指的是每次循环后执行的语句，一般用于更新循环变量的值

相应例子如下：
``` C
for( ; ; fahr += 1){
	表达式;
}
```
第三个式子与前面一样，可以省略不写，但如果不在循环体内更新变量的话，可能会导致无限循环

---
下面通过一个例子来说明具体的用法
``` C
for(fahr = 0; fahr <= 300; fahr += 150){
	printf("%3.1f\n", fahr);
}
```

首先这个循环先定义变量`fahr`为0，之后开始执行循环，每次循环打印一次`fahr`

同时在每次训话循环结束后，变量`fahr`的值增加150，直到`fahr`的值大于300的时候结束循环

---
## 符号常量
符号常量指的是将一个符号定义为一个字符串

例如，可以将300定义为`UPPER`

在C语言中，使用符号常量的办法是利用`#define`

具体操作方法如下：
``` C
#define 符号常量名称 要替换的文本
```

例如：
``` C
#define UPPER 300
```

利用这个小方法，我们之前的例子可以改写为：
``` C
#define LOWER 0
#define UPPER 300
#define STEP 150
int main() {
	float fahr;
		for (fahr = LOWER; fahr <= UPPER; fahr += STEP) {
			printf("%3.1f \t %6.1f\n", fahr, (5.0 / 9.0) * (fahr - 32));
		}
}
```

相较于之前的直接在`main()`里面定义变量，这种方法会更加直观（前提是你的符号常量是明确的，无歧义的）

另外，细心的人可能发现了，用`#define`定义符号常量的时候并不需要在末尾加分号

还需要注意一点的是，符号常量的名字一般来讲是大写，为了与其他用小写的变量名作区分

### 拓展内容
以下内容K&R书中在第一章未提及

**#define 的本质**
#define 的本质为文本替换，也就是说在编译前的**预处理**阶段，会把整个程序里面出现的符号变量的名字（不包括在引号里面的）替换为替换文本的东西

以上面的例子为例，在预处理阶段会扫一遍有没有单独出现的`UPPER`，如果有，就替换为`300`

---
## 文件复制
接下来来讲讲文件复制

在这里需要用到两个全新的函数`getchar()`和`putchar()`

其中`getchar()`为获取输入，例如：
``` C
c = getchar();
```

此时变量`c`就被赋予了对应的输入内容

接下来是`putchar()`，作用为输出括号内的内容，例如：
``` C
putchar(c);
```

这样就输出了变量`c`的内容

接下来通过一个具体的例子来说明一下使用的方法：

``` C
#include <stdio.h>
int main(){
	int c;

	c = getchar();
	while(c != EOF){
		putchar(c);
		c = getchar();
	}
}
```

通过上面的代码，我们便实现了一个输出的内容为输入的内容的小工具

相当于复制后自动输出的效果

这里要说明一下，`EOF`指的是`end of file`，通过按`Ctrl+Z`后回车即可触发

当然，还可以把上面的这个写的更加紧凑一点：
``` C
#include <stdio.h>
int main(){
	int c;

	;
	while((c = getchar()) != EOF){
		putchar(c);
	}
}
```
接下来讲解一下

首先循环第一步，请求输入，并把输入的内容赋值给`变量c`，而后开始判断，如果`变量c`不为`EOF`，则继续执行，否则直接结束循环

这里要特别注意的一点是，`while`括号内必须这样写，才可以正常识别

这是由于在C语言中，不等于运算符!=的优先度是大于赋值运算符的=，正因如此，如果没加括号，则会变成这样子：

## 文件复制
接下来来讲讲文件复制

在这里需要用到两个全新的函数`getchar()`和`putchar()`

其中`getchar()`为获取输入，例如：
``` C
c = getchar();
```

此时变量`c`就被赋予了对应的输入内容

接下来是`putchar()`，作用为输出括号内的内容，例如：
``` C
putchar(c);
```

这样就输出了变量`c`的内容

接下来通过一个具体的例子来说明一下使用的方法：

``` C
#include <stdio.h>
int main(){
	int c;

	c = getchar();
	while(c != EOF){
		putchar(c);
		c = getchar();
	}
}
```

通过上面的代码，我们便实现了一个输出的内容为输入的内容的小工具

相当于复制后自动输出的效果

这里要说明一下，`EOF`指的是`end of file`，通过按`Ctrl+Z`后回车即可触发

当然，还可以把上面的这个写的更加紧凑一点：
``` C
#include <stdio.h>
int main(){
	int c;

	while((c = getchar()) != EOF){
		putchar(c);
	}
}
```
接下来讲解一下

首先循环第一步，请求输入，并把输入的内容赋值给`变量c`，而后开始判断，如果`变量c`不为`EOF`，则继续执行，否则直接结束循环

这里要特别注意的一点是，`while`括号内必须这样写，才可以正常识别

这是由于在C语言中，不等于运算符!=的优先度是大于赋值运算符的=，正因如此，如果没加括号，则会变成这样子：
``` C
#include <stdio.h>
int main() {
	int c;

	while (c = (getchar() != EOF)) {
		printf("%d",c);
	}
}
```

这样就变成了先判断输入的数是不是EOF，如果不是，赋值`变量c`为1，如果是的话则赋值为0

这样就变成了先判断输入的数是不是EOF，此时返回的结果为一个布尔值，**True为1，False为0**

此时变量c的结果只有**1或0**

需要注意的一点是，这里使用的类型为`int`，而不是`char`

这是因为`EOF`的值为`-1`，超出了`char`的范围（0~255）

当然，也有一种情况`char`的范围为（-128~127），但在这种情况，有些字符会被判断为负值（例如扩展 ASCII 码的128~255），这个时候便会与`EOF`混淆

### 拓展内容
如果你试着执行上面括号不对的版本并输入

你会发现输出的内容并不是一个单独的1

这是因为你输入的内容都会进行一次判断，每次判断都会输出相应的内容

比如你输入`123`，那么会以此判断`1`和`2`和`3`

这时候就又会发现，诶，输出怎么是4个1，这是因为你输入的时候还需要回车，回车是换行符`\n`，也需要进行一次判断，这就导致了有4个1

## 字符计数
接下来学习一个新的运算符`++`

这个运算符的作用是使得这个变量加一，具体效果如下：
``` C
++nc;
```

此时nc的值会加一

那么有什么作用呢，接下来通过一个例子来说明

``` C
#include <stdio.h>

int main(){
	long nc;

	nc += 0
	while(getchar() != EOF){
		++nc;
	}
	printf("%ld",nc);
}
```

这段代码的大意为：每次执行循环若不为`EOF`，则变量`nc`的值加一

输入为`EOF`的时候，退出循环，并且打印`nc`的值

这里还有一个需要补充的点

可以看到这里有一个新的数据类型：`long`

这个类型的特点如下：

在一些机器上`int`和`long`的长度相同，但在一些机器上，`int`类型长度只有16位的存储单元的长度(最大值为32767)

而`long`类型的存储单元长度有**32位**(差不多21亿)，这就可以避免了输入过多导致报错的情况

对应的格式为`%ld`

此外还有另外一个数据类型：`double`可以储存的长度为**64位**

``` C
#include <stdio.h>

int main() {
	double nc;

	for (nc = 0; getchar() != EOF; nc++)
		;
	printf("%.0f\n", nc);
}
```
在这个语句中，for的循环体是空的，但由于C语言的语法规则要求必须有一个循环体，所以这里用一个单独的分号来表示

像这样的单独一个分号被称为**空语句**

这里需要说明的一点是，`while语句`和`for语句`的一大有点就是在执行循环体之前就会对条件进行测试

如果条件不满足，则不会执行循环体