# 第二章
类型、运算符与表达式

本章主要围绕这一部分展开，主要为变量与常量，数据类型之间的转换，运算符等内容

## 变量名
接下来讲讲变量名的格式

相较于Python的宽松，C语言对于变量名的要求变得比较严格

首先变量名只能有字母和数字组成（C11标准后支撑Unicode字符，但说实话正常不会用到），并且第一位必须为字母，而不能为数字，一般来讲下划线`_`是被看作字母的，一般用于比较长的变量名中，增强其可读性

由于库例程（由编程语言的标准库、第三方库或自定义库预先实现的、具备特定功能的函数（或子程序），例如printf()）一般以下划线开头，所以变量名一般不以下划线开头

一般来讲，变量使用的字符为小写字母，而符号常量使用的字母为大写字母（如第一章的MAXLINE）

接下来需要说明一点的事变量名不能与程序内部已有的关键字重复（例如`else`、`if`、`for`等），这些是保留给语言本身用的，这些关键字的字符必须都是小写

一般来讲，选择的变量名要尽可能的表达出这个变量的作用（比如说`line`等），**尽量不要使用抽象的变量名**(如`a`,`b`,`c`)

局部变量一般使用较短的变量名，循环变量（如`for语句`中）要使用较短的变量名，而外部变量使用较长的名字

## 数据类型及长度
C语言里面有一些数据类型：
<table>
    <thead>
        <tr>
            <th>数据类型</th>
            <th>长度</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>char（字符型）</td>
            <td>占用一个字节，存放本地字符集的一个字符</td>
        </tr>
        <tr>
            <td>int（整型）</td>
            <td>通常整型反映了机器中整数的最自然长度</td>
        </tr>
        <tr>
            <td>float（单精度浮点型）</td>
            <td rowspan = "2">可以显示小数点后的位数，这里需要说明一下单精度和双精度的区别，单精度说明这个的精度只能确保到小数点后6~7位，而双精度则可以确保到小数点后15~17位。此外，双精度使用的内存要比单精度要高</td>
        </tr>
        <tr>
            <td>double（双精度浮点型）</td>
        </tr>
    </tbody>
</table>
本地字符集：指当前操作系统、编译器或运行环境默认使用的字符与二进制数据的映射规则，规定了一个字母对应的二进制数据

### 限定符
在声明的时候，还可以在前面加上一些限定符`short`和`long`来限定整型
``` C
short int nums;
long int nums;
```

需要说明的一点是，如果选择上面这种类型的声明，则可以把`int`省略
``` C
short nums;
long nums;
```

接下来来说明这两种有什么不同

`short类型`的长度为16位（大概6.5万个数），而`long类型`长度有32位（大概有43亿个数）

可以看到，`long类型`要远远大于`short类型`

int类型可以为16位或者32位，需要注意的是各个编译器可以根据硬件特性选择合适的长度，但要遵循一定的限制

`short`与`int`至少为**16位**，而`long`至少为**32位**，并且`short`不能长于`int类型`，而`int类型`不得长于`long类型`

接下来将另一个限定符：`signed`和`unsigned`

这两个限定符可以限定`char类型`或者是任何整型：
``` C
unsigned int nums;
```

`signed`限定符范围包括了负数，比如说`signed short`的范围就是 **-32768~32767** 而`unsigned`就是只有正数部分以及0，也就是`0~65535`

这里补充的一点是一般来讲不填就是默认为`signed`（也就是支持正负数），所以一般`signed`可以省略

`unsigned`类型遵循了算数模2^$n$定律，n为该类型占用的位数

> 什么是算数模2的n次方定律？
> 指的是整数在模 2ⁿ（即对 2 的 n 次方取余数）运算下的一系列特殊规律
> 对于任意整数 x，x mod 2ⁿ的结果等价于 x 的二进制表示中最后 n 位所对应的数值。
>
> 举个例子：70 mod 32的计算过程如下
> 70 转换为二进制：1000110
> 32 为2的5次方，所以n为5，取最后五位（00110）
>
> 接下来从右往左看：
> 0 x 1 = 0
> 1 x 2 = 2
> 1 x 4 = 4
> 0 x 8 = 0
> 0 x 16 = 0
>
> 结果为6，所以 70 mod 32 结果为 6