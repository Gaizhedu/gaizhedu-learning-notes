# 第二章
类型、运算符与表达式

本章主要围绕这一部分展开，主要为变量与常量，数据类型之间的转换，运算符等内容

## 变量名
接下来讲讲变量名的格式

相较于Python的宽松，C语言对于变量名的要求变得比较严格

首先变量名只能有字母和数字组成（C11标准后支撑Unicode字符，但说实话正常不会用到），并且第一位必须为字母，而不能为数字，一般来讲下划线`_`是被看作字母的，一般用于比较长的变量名中，增强其可读性

由于库例程（由编程语言的标准库、第三方库或自定义库预先实现的、具备特定功能的函数（或子程序），例如printf()）一般以下划线开头，所以变量名一般不以下划线开头

一般来讲，变量使用的字符为小写字母，而符号常量使用的字母为大写字母（如第一章的MAXLINE）

接下来需要说明一点的事变量名不能与程序内部已有的关键字重复（例如`else`、`if`、`for`等），这些是保留给语言本身用的，这些关键字的字符必须都是小写

一般来讲，选择的变量名要尽可能的表达出这个变量的作用（比如说`line`等），**尽量不要使用抽象的变量名**(如`a`,`b`,`c`)

局部变量一般使用较短的变量名，循环变量（如`for语句`中）要使用较短的变量名，而外部变量使用较长的名字

## 数据类型及长度
C语言里面有一些数据类型：
<table>
    <thead>
        <tr>
            <th>数据类型</th>
            <th>长度</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>char（字符型）</td>
            <td>占用一个字节，存放本地字符集的一个字符</td>
        </tr>
        <tr>
            <td>int（整型）</td>
            <td>通常整型反映了机器中整数的最自然长度</td>
        </tr>
        <tr>
            <td>float（单精度浮点型）</td>
            <td rowspan = "2">可以显示小数点后的位数，这里需要说明一下单精度和双精度的区别，单精度说明这个的精度只能确保到小数点后6~7位，而双精度则可以确保到小数点后15~17位。此外，双精度使用的内存要比单精度要高</td>
        </tr>
        <tr>
            <td>double（双精度浮点型）</td>
        </tr>
    </tbody>
</table>
本地字符集：指当前操作系统、编译器或运行环境默认使用的字符与二进制数据的映射规则，规定了一个字母对应的二进制数据

### 限定符
在声明的时候，还可以在前面加上一些限定符`short`和`long`来限定整型
``` C
short int nums;
long int nums;
```

需要说明的一点是，如果选择上面这种类型的声明，则可以把`int`省略
``` C
short nums;
long nums;
```

接下来来说明这两种有什么不同

`short类型`的长度为16位（大概6.5万个数），而`long类型`长度有32位（大概有43亿个数）

可以看到，`long类型`要远远大于`short类型`

int类型可以为16位或者32位，需要注意的是各个编译器可以根据硬件特性选择合适的长度，但要遵循一定的限制

`short`与`int`至少为**16位**，而`long`至少为**32位**，并且`short`不能长于`int类型`，而`int类型`不得长于`long类型`

接下来将另一个限定符：`signed`和`unsigned`

这两个限定符可以限定`char类型`或者是任何整型：
``` C
unsigned int nums;
```

`signed`限定符范围包括了负数，比如说`signed short`的范围就是 **-32768~32767** 而`unsigned`就是只有正数部分以及0，也就是`0~65535`

这里补充的一点是一般来讲不填就是默认为`signed`（也就是支持正负数），所以一般`signed`可以省略

`unsigned`类型遵循了算数模2^$n$定律，n为该类型占用的位数

> 什么是算数模2的n次方定律？
> 指的是整数在模 2ⁿ（即对 2 的 n 次方取余数）运算下的一系列特殊规律
> 对于任意整数 x，x mod 2ⁿ的结果等价于 x 的二进制表示中最后 n 位所对应的数值。
>
> 举个例子：70 mod 32的计算过程如下
> 70 转换为二进制：1000110
> 32 为2的5次方，所以n为5，取最后五位（00110）
>
> 接下来从右往左看：
> 0 x 1 = 0
> 1 x 2 = 2
> 1 x 4 = 4
> 0 x 8 = 0
> 0 x 16 = 0
>
> 结果为6，所以 70 mod 32 结果为 6

## 常量
接下来讲讲2.3 常量

首先让我们先明白各个常量的表示方法

类似于1 2 3 4 5 6的整数常量属于`int类型`

而`long类型`不同于`int类型`，会在数字的最末尾加一个`l`或者`L`，例如`123123123l`

如果有些数字大到超过了`int类型`，**则归于long类型**，也会在数字的最后面加一个`l`

无符号常量`unsigned`以`u`或者`U`结尾，如果是`unsigned long`，则会以`ul`或者`UL`结尾

接下来是浮点数常量，浮点数常量包含一个小数点或者一个指数（1e-2），当然两者都有也可以

有些浮点数常量没有后缀，被称为`double`类型，如果有`f`或者`F`后缀，则为`float类型`

如果一个浮点数出现了`l`或者`L`后缀，则为`long double`类型

### 进制表示
接下来讲讲进制的表示方法

整形数除了使用十进制外，还可以使用到八进制或者十六进制

其规则可以通过十进制类比：

十进制是满十加一，以此类推八进制就是满八进一，十六进制就是满十六进一

这时候就有人要问了，阿拉伯数字只有10个，怎么表示出16个数字啊

十六进制使用了字母作为后面10~15的表示

例如：A代表10，B代表11，C代表12，D代表13，E代表14，F代表15

接下来利用这个就可以转化数字了

例如说十进制20就是八进制24，十六进制的14

---
讲解完规则会就可以步入正题了

首先第一个，在C语言中，带前缀0的整型常量表示为八进制形式，例如上面的十进制的20就是八进制的024

而十六进制的前缀通常为`0x`或者`0X`，上文的十进制20就是十六进制的0x14

这些常量都可以加上上文提到的后缀`L`或者`U`

### 字符常量
接下来讲讲字符常量，需要说明一点的是，**一个字符常量就是一个整数**，书写的时候一般把一个字符扩在单引号里面

例如`'0'`，这些字符在机器字符集中的数值就是字符常量的值，比如说在ASCII中，`'0'`对应的值为`48`（这个值跟数值的0没关系）

一般来讲，字符常量是与其他字符来比较，当然也可以参加运算（比如说上一章的`c - '0'`）

在一些字符中，可以通过转义来表示字符和字符串常量，比如说换行符`\n`

这些看起来好像是多个字符，但由于**一个字符常量就是一个数**，所以其实是一个字符

另外，反斜杠还有很多用法，比如说可以这样表示一个八进制的数字：`\000`，这里需要注意的是

长度最大就是3位，**不可以超过3位**

另外还有一种表示十六进制的方法是`\xhh`，这里的`h`表示`0~F`的任意一个数

ANSI C语言全部的转义字符序列如下所示：
<table>
    <thead>
        <tr>
            <th>表示</th>
            <th>名称</th>
            <th>表示</th>
            <th>名称</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>\a</td>
            <td>响铃符</td>
            <td>\\</td>
            <td>反斜杠</td>
        </tr>
        <tr>
            <td>\b</td>
            <td>回退符</td>
            <td>\?</td>
            <td>问号</td>
        </tr>
        <tr>
            <td>\f</td>
            <td>换页符</td>
            <td>\'</td>
            <td>单引号</td>
        </tr>
        <tr>
            <td>\n</td>
            <td>换行符</td>
            <td>\"</td>
            <td>双引号</td>
        </tr>
        <tr>
            <td>\r</td>
            <td>回车符</td>
            <td>\000</td>
            <td>八进制数</td>
        </tr>
        <tr>
            <td>\t</td>
            <td>横向制表符</td>
            <td>\xhh</td>
            <td>十六进制数</td>
        </tr>
        <tr>
            <td>\v</td>
            <td>纵向制表符</td>
            <td></td>
            <td></td>
        </tr>
    </tbody>
</table>

字符常量`'0'`表示属性为0的字符，也就是空字符`null`，通常用`'\0'`来代替0

### 常量表达式
常量表达式是仅仅包含常量的表达式，这种表达式在编译的时候就会求值（比如说20 + 30、123）

这种表达式可以出现在任何常量可以出现的地方

### 字符串常量
字符串常量指的是用双引号围起来的字符序列，比如说`"hello world"`

双引号内部允许没有字符：`""`

需要注意的一点是，双引号并不作为字符串的内容，只是告诉编译器这个被围起来的地方是字符串而已

那些在字符常量中使用的转义类型也可以使用在字符串中，比如说可以在字符串中使用`\"`来表示双引号

这有什么作用呢

举个例子：
```C
s = "He is a "dreamer".But I don't believe him"
```
上面的句子中，由于句子内部`dreamer`加了双引号导致了句子被错误切割为`He is a `和`.But I don't believe him`两部分

这时候便可以使用到字符常量来表示句子中的双引号：
``` C
s = "He is a \"dreamer\".But I don't believe him"
```
现在就是一个完整的句子了

在上一章中有提及到字符串的结束以`\0`为标志，这里便不多概述

需要补充的一点是，由于这个原因，C语言对字符串的大小并没有限制（因为无论如何都得在最后面加上`\0`作为结尾）

### 枚举常量
接下来是枚举常量，枚举是一个常数整型值的列表，一般用`enum`表示
``` C
enum boolean {NO, YES};
```
如果你没有进行显式声明那么`enum`的第一个值为0，之后第二个为1，第三个为3，以此类推

如果你只是制定了部分枚举名的值，那么那些为指定的会根据最后一个指定的值往后递增
``` C
enum WEEK {SUNDAY = 1, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY}
```
这样，往后的结果就会是：MONDAY = 2，TUESDAY = 3，以此类推

需要注意的是不同枚举中的名字必须互不相同，比如说不能出现多个`MONDAY`，但是同个枚举不同的名字可以指定同一个值

比如上面我可以指定全部的星期全为一，这样在用户输入星期的时候可以根据枚举的值的不同转换到不同的模块上

#### 补充点：#define 和 enum的不同
虽然说两者都可以让常量值和名字之间相关联，但是两者有一些不同

像是#define就没办法自动迭代，需要自己一个一个输入，并且你输入的常量值编译器是不检查是否存在问题的

但是enum会检查这种变量中储存得知是否为该枚举的有效值

另外，如果你尝试使用调试程序打印#define的值，就会发现会直接打印出对应的值，而不是值对应的名字

但是enum在调试中则会显示出这个值的名字，这也是为什么枚举会比较有优势

## 声明
接下来讲讲声明，这里强调一个点：**所有变量都要先声明之后使用**，虽然有时可以通过上下文隐式声明

接下来讲讲一些声明的方法：
``` C
int num1, upper, lower;
float step, way, maxline;
```

上面这种声明的方法可以一次性声明多个变量

如果想要一个一个声明也是可以的
``` C
int num1;
int upper;
int lower;
float step;
float way;
float maxline;
```

这种声明方式虽然说占用比较大的空间，但是好处是添加注释的时候比较方便

此外，在声明的时候你还可以对这些变量初始化：
``` C
int step = 20;
int upper = 30;
```

如果这个变量不是自动变量（局部变量）的话，那么只能进行一次初始化操作，并且初始化还必须是常量表达式

如果是自动变量的话，那么每次进入函数或者是程序块的时候，显示表达式的自动变量就会被初始化一次

没有经过显式初始化的自动变量的值为未定义值（也就是无效的值）

### const
`const`是一个限定符，如果被这个限定符限定，那么这个变量将无法被修改

如果用const限定一个数组，那么这个数组的所有元素的值都无法被修改
``` C
const double e = 2.71828182845905;
```
当然，这个限定符还可以搭配数组参数使用，表明函数不能修改数组元素的值

## 算数运算符
接下来讲讲算数运算符：`+、-、*、/、%`

加减乘除这里不做介绍，这里主要介绍`%`，意思是**取模**，也就是求余数
``` C
x % y
```
代表`x`除于`y`后得到的余数，如果为整除的话那么计算的结果为0

需要注意的一点是这个计算符并不适用于float 或 double类型，这一点需要特别注意

接下来说明一个K&R的历史遗留问题，里面提及了这一句话：

> 在有负操作数的情况下，整数除法截取的方向以及取模运算结果的符号取决于具体机器的实现，这和处理上溢或下溢的情况是一样的。

这里由于K&R的发布原因，在标准C99之后统一了截取方向为**向零截取**，也就是直接截断小数部分

而取模结果的符号必须与被除数一致

说白了就是在C99标准下：
``` C
-5 % 3 = -2
5 % -3 = 2
```

具体公式如下：`被除数 = 除数 × (被除数/除数) + (被除数%除数)`

## 关系运算符与逻辑运算符
接下来讲讲关系运算符和逻辑运算符

关系运算符包括下面几种：`> >= , <=`

这几种的优先级是相同的，不会遇到说哪一个的优先级更高的情况

仅次于这些运算符的时相等性运算符：`== !=`

这里的运算符优先级为：`算术运算符 > 关系运算符 > 相等性运算符`

优先级指的是在一条式子中谁先谁后的关系

比如说：`i < lim - 1`

这里由于算数运算符优先于关系运算符的原因，会优先计算`lim - 1`

其次就是`赋值运算符`小于`关系运算符`

这时候可能有回想起一个在第一章经常用的表达式`(c = getchar()) != EOF`

这里也是因为这个原因，如果不加括号会先检测输入内容是否为`EOF`，如果是的话变量`c`就是1，否则就是0

接下来介绍`逻辑运算符`，`&& ||`

`&&`表示为`and`，而`||`表示为`or`

其中`&&`的优先级要大于`||`，还有就是逻辑运算符的优先级要比关系运算符和相等性运算符的优先级低

---
在关系表达式或逻辑表达式中，如果关系为真的话，那么表达式的结果值为1，反之为0

通过逻辑非运算符可以将翻转这个结果：
``` C
bl = 1;
if(!bl) //bl为0的时候执行
```

一般来讲不写成这样子：
``` C
bl = 1
if(bl == 0)
```

## 类型转换
**本节问题**
1. 如何实现类型的转换
2. 实现类型的转换需要注意什么

接下来讲讲如何实现类型之间的转换

一般来讲，类型转换通常将小范围的数转换为大范围的数，例如把`int`转为`float`

举个例子来说明：
``` C
int atoi(const char s[]);

int main(void) {
    printf("%d",atoi("2"));
}

int atoi(const char s[]){
    int n = 0;

    for (int i = 0; s[i] >= '0' && s[i] <= '9';++i) {
        n = 10 * n + (s[i] - '0');
    }
    return n;
}

// 输出：2
```
在上面这里例子中，我们可以看到一个这里将字符串转换为整型数

接下来来讲讲是及如何实现的

首先先让我们分析一下输入的是什么内容：`"2"`，可以看到是一个字符串

而看到函数的定义，可以看到参数的类型属于`char`，也就是字符

由于`char`只能为一个字符，所以我们得想到必须得把输入的内容一个字符一个字符地加上去

这里如何叠加先按下不表，继续回到思路

所以如何才能让这个一个字符一个字符地慢慢读取呢？

这时候可以类比一下Python的列表
``` Python
list_step = [x for x in "hello"]
print(list_step)

for i in range(len(list_step)):
    print(f"第{i + 1}项是{list_step[i]}")

# 输出
# ['h', 'e', 'l', 'l', 'o']
# 第1项是h
# 第2项是e
# 第3项是l
# 第4项是l
# 第5项是o
```
可以看到，这里输入的内容就被逐一拆分到列表里面了，需要的时候直接读取对应的项数皆可

那么按照这个道理，我们也可以把字符串中的每一项都加到一个新的数组中，之后依次转换，最后把结果拼合

首先需要明白一个点**字符串的本质是一个以"\0"结尾的char数组**这也就是为什么参数为char的原因

这时候就有人要问了，诶，前面不是有提到说`char`只能存储一个字符吗，确实，`char`类型只能存储一个字符，但这里是一个`char`数组，可以存储多个字符，举个例子
``` C
char s = "123" // 错误，必须为一个字符，这是一个char变量
char s[] = "123" // 正确，这是一个数组，是一个char数组
```

理解完这个后，我们便可以利用这个道理来存储字符串了

``` C
// 函数的定义是什么样的，那么显式声明得是怎么样的，这里定义是数组，那么声明就得是数组
// 但是前文也说过了，名字可以不同
// 这里用了const限定，那么之后也得用const限定
int atoi(const char s[]);

int main(void) {
    printf("%d", atoi("123"));
    return 0;
}

int atoi(const char s[]) {
    int n = 0;
    // char s[i]是一个ASCII值，要减去字符0的ASCII值（'0'）才可以得出结果
    for (int i = 0;s[i] >= '0'&& s[i]<='9';++i) {
        n = 10 * n + (s[i] - '0');
    }
    return n;
}
```
其他杂项的内容已经讲过了，这里讲一下核心，如何实现更新数字

这里用了一个很简单的方法，我们不妨思考一下我们输入的是什么？对，我们输入的是一个一串数字

既然是数字，就肯定有位数，那么如何才能实现进位？进位其实也就是在原先的后面加上一个0，所以可以用`10 * n`来解决

那么要怎么实现数字的更新呢，由于每次转换得到的数字是位于`0 ~ 9`之间的，也就是说不可能实现跨位数

既然无法实现跨位数，所以只能在个位数做功夫。这时候不妨想想看，怎么样就可以让这个新数字无损地加上去

没错，就是把新的数字的那一位令为0，之后把新的数字加上去就可以实现不破坏数字了

这也就是这个的来历：`n = 10 * n + (s[i] - '0')`

`s[i] - '0'`代表新的数字

`10 * n`代表新的数字的那一位初始化为0

之后相加，由于新的数字不可能造成进位，所以不会修改原有的数字（例如不会使得350变成360，如果会的话就进位了）

这就合理的把新的数字加了上去

---
### 隐式算数类型转换
首先先科普一个概念，**什么是二元运算符**

二元运算符指的是具有两个操作数的运算符，比如说加减乘除，这些运算符如果想要正常运行则必须要有两个操作数

说明完成后进入正题

在C语言中，很多情况下都会进行隐式的算数类型转换，什么意思呢？

比如说如果在二元运算符中，两个操作数的类型是不同的话（比如说一个为int，一个为float），那么那些较低范围的类型会被转换为较大的数字类型（上文的int会转换为float）

如果将一个较长的整数转换为一个较短的整数或char类型时，超出的高位部分将会被抛弃

举个例子：
``` C
int i = 1000;
float f = 1234.1234;

i = f;
f = i;
```
这样的话，i由于是更小的范围，使得小数点后面的数被舍弃了，之后f重新赋值也可以看到小数点后的数字都没有了

### 强制类型转换
所有的表达式都可以使用强制类型转换，也就是说可以把一个类型强制转为其他的类型

具体的表达式如下：`(类型名) 表达式`

举个例子：

函数`sqrt()`的参数为`double`，如果如果传进去的类型是整数的话会导致出现问题（假设这里为n）
``` C
int n;
sqrt(n);
```
这样会导致出现问题

这时便可以使用强制类型转化了，以这里为例的话：
``` C
int n;
sqrt((double) n);
```
这样的话，n就被转换为符合规范的类型了

需要注意的一点是，强制类型转换只是**生成一个新的n，原来的n并没有发生改变**

在一般的情况下，函数的参数是通过函数原型声明的，通过函数声明，可以自动将参数进行强制类型转换

在 K&R 涉及的早期C标准中，如果没有显式声明函数原型（如 `double sqrt(double);`），编译器可能无法自动转换参数类型，此时强制转换就成了必须

## 自增运算符与自减运算符
**本节问题**
1. 自增运算符的前后缀有什么区别，又有什么共同点
2. 在使用的时候要注意什么问题
3. 自增运算符的前缀等于后缀的什么

> 由于自增运算符跟自减运算符的使用方法完全一致，这里笔记仅使用自增运算符作为示例

自增运算符可以用于变量的递增，每次使用自增运算符会使得变量的值**增加1**，在前面的许多例子中已经有使用过

C语言同样支持以下格式来实现递增：
``` C
n += 1;
```

使用自增运算符的格式如下：
``` C
++i // 前缀用法
i++ // 后缀用法

```
### 前缀与后缀
接下来讲讲前缀和后缀的共同点：前缀和后缀都可以使得变量增加1

这两者的不同点是中间步骤的不同

前缀的用法是先让变量的值加一，之后再使用变量的值

而后缀的用法是先使用变量的值，之后再使得变量的值加一

具体的差异如下所示：
``` C
int main() {
    char s[] = "123";
    int i = 0,o = 0;
    printf("%d, %d\n",s[++i] - '0',s[o++] - '0');
    printf("%d, %d\n",i,o);
}

// 输出：2, 1
// 1, 1
```
可以看到，虽然最后两个变量的结果都是1，但是在使用的时候却出现了截然不同的结果

使用前缀的变量`++i`返回的结果是数组中的第二项`2`

而使用后缀的变量`o++`返回的结果是数组中的第一项`1`

这也证实了之前的说法

> 有个形象化的记忆是，前缀的++可以代表为先加，之后在使用变量
> 而后缀由于变量在前++在后，可以看成先使用变量再加

需要注意的一个点是，自增运算符只能用于变量，**不可以用于表达式**

例如`(i + o)++`是**不被允许的**

如果在使用自增运算符的时候进需要递增变量，那么前后缀没有任何差别

但是如果需要用到具体的值的时候，这两者便有了差异（比如之前的例子）

---
### 启发
通过上面的例子中我们可以想到一些做法

比如我想把一个输入的字符串拷贝到一个新的数组中，可以怎么办

首先大体思路为将原数组的值一个一个拷贝进去新数组

有了大体思路后便可以开始着手了

``` C
int copylist(const char s[]);
char to[1000];

int main() {
    copylist("1233321");
    printf("%s",to);
    return 0;
}

int copylist(const char s[]){
    int i = 0;

    while ((to[i] = s[i]) != '\0')
        ++i;
    return 0;
}
```

如果使用后缀则如下：
``` C
int copylist(const char s[]);
char to[1000];

int main() {
    copylist("1233321");
    printf("%s",to);
    return 0;
}

int copylist(const char s[]){
    int i = 0;
    int o = i;

    while (s[i] != '\0')
        to[i++] = s[o++];
    return 0;
}
```
虽然最后变量的值是相等的，但是从上面的例子可以看出其中间的过程是不同的

一般来讲，前缀和后缀可以在某些程度上等同
``` C
s[i] = c;
++i;
```
等同于
``` C
s[i++] = c;
```

### 特殊拓展：未定义行为
这里可能会犯一个错误，也就是这个地方：`to[i++] = s[o++];`，看起来好像没什么，但是你可能在脑海中有过一点思考：这里用两个变量不是在浪费空间吗，直接`to[i++] = s[i++];`不可以吗？

诶，还真不可以

这里就要提到一个新的概念：**未定义行为（Undefined Behavior）**

什么是未定义行为呢？在C语言中，如果你在同个语句对单个变量进行多次修改，那么这个行为就是未定义的

也就是说C语言没有规定编译器要怎么做，不同的编译器对同一个未定义的语句可能有不同的结果

比如说上面这个例子：编译器可能先计算`to[i++]`，之后再计算`s[i++]`；也有可能反过来，先计算`s[i++]`，之后再计算`to[i++]`

所以这里也就是为什么要用两个变量的原因

### 高效与低效
前缀和后缀虽然看起来差不多，但实际上两者的效率是有差别的，一般而言：**前缀要比后缀效率更高**

这是为什么呢？从底层讲的话，前缀是直接修改后引用，而后缀是先**创建一个变量的副本**，而后去修改原有的值，最后返回创建的副本

则后缀要比前缀多一个副本的开销

## 位运算符
**本节问题**
1. 位操作符有哪些？要怎么用
2. 如何利用位操作符得到想要的位数

在C语言中提供了六个运算符，分别是：`& | ^ << >> ~`

接下来逐一介绍其用途

### &（按位与）
按位与&是一个运算符，等价于逻辑门中的**AND（与门）**，其基本格式如下：
``` C
x & y;
```
其中我们把`x`称为**左操作数**，`y`称为**右操作数**，具体的使用方法是，将左操作数和右操作数分别转化为二进制数

之后将两者比较，如果两者位数不相同，那么短的数将用`0`补全缺的位数

而按位与的核心功能是，**如果两个数均为1，那么结果为1，否则为0**

举个例子：
``` C
2025 & 31；
```
首先将两者分别转成二进制，分别为`11111101001`和`11111`，由于右操作数的位数小于左操作数，则左操作数将缺的位数用`0`补全：

最后两者对比前的结果如下：
```
2025:11111101001
  31:00000011111
```

之后找到符合规则的则为一，不符合规则的则为0

结果如下：
```
00000001001
```
之后开始化简，直到第一位为1，最后结果为`1001`，也就是十进制的**9**

也就是说，`2025 & 31`的输出结果为`9`

---
当然，右操作数除了使用十进制，还可以使用其他的进制

这里除了补充这一点之外，还有其他的内容

通过按位与的特性，我们似乎可以想到什么

既然只有两个为1的时候才是1，否则为0，那么是不是可以想到什么东西

诶，如果给的右操作数的二进制均为1，那么是不是就可以起到保留指定位数的作用

事实确实如此，以上面的例子为例，这里如果转换一下，保留左操作数的前5位，那么也可以使用这样的格式

[TODO] 记得补其他进制的表示方式