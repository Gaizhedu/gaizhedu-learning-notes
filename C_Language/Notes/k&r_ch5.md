# 指针与数组

这一章将说明有关指针的内容

## 导言
首先我们先理解一下什么是指针，指针是一种保存变量地址的变量。在C语言中，指针的使用十分广泛，并且如果合理使用指针，那么会大幅度的简化操作，完成更加高效和紧凑的代码

需要注意的一点是，从ANSI C后，指针使用void\*代替char\*作为通用指针的类型

## 指针与地址
接下来开始正式介绍指针

### 内存是怎么组织的
通常来讲，机器都有一些列连续编号或者编址的存储单元，这些存储单元你可以单个进行操纵，也可以连续的成组操纵

一个字节可以存储一个`char`类型，而两个相邻的字节类型可以存储一个`short`类型的数据，而如果是相邻的四个字节存储单元可以存储一个long类型的数据

而指针是一个可以存放一个地址的一组存储单元

### 正文
在介绍内存是怎么组织的之后，便要开始讲正题了，首先先介绍一下一元运算符`&`

具体用法如下：
``` C
p = &c
```

这里把c的地址赋值给p，所以我们称p为指向C的指针，需要注意的一点是地址运算符&只能应用于内存中的对象，也就是变量和数组元素，并且不能作用于表达式、常量和寄存器变量

一元运算符*是间接寻址或者是间接引用运算符，当他作用于指针的时候，将访问指针所指向的对象

下面通过一个例子来说明这一点：
``` C
int x = 1,y = 2, z[10];

int *ip;

ip = &x;
y = *ip;
*ip = 0;
ip = &z[0];
```
在上面的例子中，我们初始化了一个指针：`ip`

这个指针的类型为整数类型

而在初始化之后，存在一个赋值的操作：`ip = &x;`，由上文可知，&的作用是找到该变量的内存地址

这里将&x的内存地址赋值给了指针`ip`，换句话讲，也就是指针`ip`指向了`x`

而下面一个表达式则为：`y = *ip;`

由于上文将指针`ip`指向了x，而x的值为1，所以这里y会被赋值为1

下面的`*ip = 0;`指的是把指针`ip`指向的值赋值为`0`，那么什么是指针指着的值呢？上面提及过为：`x`

所以，这里也就是把x的值赋值为0

另外，指针还可以指向数组中的某一位，比如最后一个表达式：`ip = &z[0];`

简单总结一下关于指针的用法

初始化指针为`类型 *指针名;`，想要把指针指向某个元素，不需要加星号，但对应的值必须为对应的地址：`指针 = &变量名`

而如果想要把指针指向的元素赋值给变量，则需要使用*：`变量 = *指针名;`

如果想要修改指针指向的值，也需要加*：`*指针名 = 新的值;`

---
另外，指针与变量一致，对应什么类型就只能指向什么类型的值，int的指针只能指向整型数，double的指针只能指向浮点数

但是有一点不同的是，**void类型的指针可以存放任何类型的指针，但不能间接引用它本身**

指针在使用的时候跟变量有些许一致的地方：

``` C
*ip = *ip + 1;
y = *ip + 1;
*ip += 1;
++*ip;
(*ip)++
```

这里可能会出现疑惑了，诶，为什么下面的后缀要加括号呢？

那是因为如果不加括号，则会先对`ip`加1运算，**而不是对指针指向的东西进行运算**，如果不加括号，那就是对地址进行运算了

这也说明了*和++运算优先级是一致的，所以遵循从右到左的顺序

指针之间是可以互相指向的，例如：

``` C
int x = 1;

int *ip,*iq;

ip = &x;

iq = ip;
```
最后的`iq = ip;`会将指针`ip`的东西赋值给`iq`，则两者指向的东西就是一致的了

## 指针与函数参数
接下来讲讲有关指针在函数参数里面的应用

依旧从之前的一个函数讲起，在之前我们使用过这个函数`swap()`用于两个数之间的互相调换位置

``` C
void swap(int x, int y){
    int temp = y;
    y = x;
    x = temp;
}
但是，这个函数有一个比较大的缺陷，例如下面这种情况：
``` C
void swap(int x,int y);

int main() {
    int a = 1,b = 2;

    swap(a,b);
    printf("%d\t%d",a,b);
}

void swap(int x,int y) {
    int temp;
    temp = x;
    x = y;
    y = temp;
}
```
很显然，在`main()`里面，我们将两个变量传入了函数里面，企图交换位置

但是实际运行的结果，发现输出的还是原来的参数

这是因为参数传递是采用传值的方式，被传入的值会创建一个副本，从而导致了只是交换副本的值，原先的值并没有发生任何变化

这也告诉我们一个点：**调用的函数是没办法直接修改主调函数中变量的值**

那要怎么办呢？诶，这里指针就可以派上用场了

我们只需要把指针的地址传给函数，即可让两个地址交换

由于打印的时候打印的是指针指向的变量的内存地址，而交换地址后指向的位置也会随之交换，这就可以完成我们的目的

``` C
void swap(int *x,int *y);

int main() {
    int a = 1,b = 2;

    swap(&a,&b);
    printf("%d\t%d",a,b);
}

void swap(int *x,int *y) {
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}
```

接下来通过一个实际的例子来说明

我们的目的是实现一个这样的函数：`getint`，使得所有输入进去的字符全部转换为整数，并且在返回的时候返回这个整数

那么我们要怎么去设计呢？

首先，按照惯例，我们需要在输入为EOF的时候停止程序，那么便可以把是否返回EOF作为标准

``` C
#define SIZE 100
int main() {
    int n ,array[SIZE];

    for (n = 0 ;n < SIZE && getint(&array[n])!= EOF;n++) {
        ;
    }
}
```
由于getint每次都会返回输入的值，所以这里便可以作为判断的条件

接下来是函数内部的表达式

首先，依旧选择跳过所有的空白符：

``` C
while (isspace(c = getch())) {
    ;// 依旧跳过空白行
}
```

接下来检测输入的内容，如果输入的内容不等于数字，或者是不符合我们需要保留的字符（+和-），则把这个符号放入暂存区，并且返回0

``` C
if (!isdigit(c) && c != EOF && c != '+' && c != '-') {
    ungetch(c);
    return 0;
}
```
这里使用到的`ungetch(c)`是之前在逆波兰计算器中使用到的存入缓存的函数，简单来讲就是把一个字符存取缓存区，在下一次调用的时候不选择获取`getchar()`里面的数字，而是选择提取缓存区里面的数字

这里就成功筛选出来剩下的我们需要的内容了，接下来就正式进入到我们的检测了

首先，我们需要检测出是否为负数，这里的方法也简单，只需要检测当前字符是否为负号即可，如果为负号，那么判断符号的变量改为负数即可

``` C
sign = (c == '-') ? -1 : 1;
```

这里的变量`sign`是检测是否为负数的变量

接下来是检测是否为加号或减号，如果为加号或者为减号则跳过该符号继续获取输入：

``` C
if (c == '+'|| c == '-') {
    c = getch();
}
```

那么至此，我们剩下的字符就全都是数字了，主要的逻辑依旧与之前一致，每读取一位数字则乘10后加数字

由于我们传入的参数是一个地址，函数的参数是一个指针，这里等价于将内存地址赋值给指针

``` C
int *ip = &array[n];
```

接下来的步骤与之前的是一致的：

``` C
for (*pn = 0 ; isdigit(c) ; c = getch()) {
    *pn = 10 * *pn + (c - '0');
}
```
这里也就是将数字逐一增加数字的过程

在完成计算数字之后，我们便要判断是否为正负数了

也就是使用到我们之前判断是否为正负数的这个变量`sign`

``` C
*pn *= sign;
```

最后返回对应的结果

完整代码如下：
``` C
#define SIZE 1000
int getch(void);
void ungetch(int c);
int nums = 0;

int getint(int *pn);


int main() {
    int n ,array[SIZE];
    for (n = 0 ;n < SIZE && getint(&array[n]) != EOF;n++) {
        ;
    }
    for (int i = 0;i < n;++i) {
        printf("%d\n",array[i]);
    }
}

int getint(int *pn) {
    int c,sign;

    while (isspace(c = getch())) {
        ;// 依旧跳过空白行
    }
    if (!isdigit(c) && c != EOF && c != '+' && c != '-') {
        ungetch(c);
        return 0;
    }
    sign = (c == '-') ? -1 : 1;// 依旧检查符号

    if (c == '+'|| c == '-') {
        c = getch();
    }
    for (*pn = 0 ; isdigit(c) ; c = getch()) {
        *pn = 10 * *pn + (c - '0');
    }
    *pn *= sign;
    if (c != EOF) {
        ungetch(c);
    }
    return c;
}

int bufp = 0;
#define BUFMAX 100
char buf[BUFMAX];

int getch() {
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) {
    if (bufp >= BUFMAX) {
        printf("ERROR:TO MANY CHAR");
    } else {
        buf[bufp++] = c;
    }
}
```

## 指针与数组
接下来讲讲指针与数组，首先我们需要明白，指针与数组关系是十分密切的，我们可以用指针来等价替换数组下标

那么为什么要这样做呢，因为一般来讲，用指针编写的程序要比用数组下标编写的程序要更快，但代价是使用指针的程序要更难理解

首先我们先理解一下一个数组在内存中是什么储存的

数组在内存中是连续存储的，比如说：
``` C
int a[] = {1,2,3,4,5,6,7};
```
假设第一项`a[0]`的地址为：0x7ffffcbd0

那么第二项`a[1]`的地址就为：0x7ffffcbd4

诶，为什么是加4而不是加1呢？其实之前也提及到了，在这里由于我们定义的是一个整数，所以占用的空间是4个字节

这也就是为什么是加4而不是加一的原因

类似的，我们可以写出这个数列的所有地址：

``` C
a[0]: 0x7ffffcbd0
a[1]: 0x7ffffcbd4
a[2]: 0x7ffffcbd8
a[3]: 0x7ffffcbdc
a[4]: 0x7ffffcbe0
a[5]: 0x7ffffcbe4
a[6]: 0x7ffffcbe8
```

---
我们不妨假设一下，我们的指针pa的赋值语句为：`pa = &a[0];`

此时指针将指向这个`a[0]`所在的位置，换句话讲就是`pa`的值为这个地址，而加上*变成指针后就变成对应地址的值了

``` C
int main() {
    int a[] = {1,2,3,4,5,6,7},*pa = a;
    printf("a[0]: %p\n此时的值：%d",pa,*pa);
}
// 输出：
// a[0]: 0x7ffffcbd0
// 此时的值：1
```

接下来，你还可以将这个值赋值给一个新的变量：
``` C
x = *pa;
```

### 指针运算
这里先简单接触一下指针运算

这里的例子依旧为之前的数列

假设我们的`指针pa`指向的是数列的第一项，那么我们可以通过指针运算来让其指向后面的项：

``` C
pa += 1;
```
此时`指针pa`指向的地址便是下一项，也就是`a[1]`。那么同理`pa + i`就是后面第i个元素

### 下标与指针运算
在上文的例子中，我们有这么一个赋值：
``` C
pa = &a[0];
```

但事实上，我们可以这样写：
``` C
pa = a;
```
如果将一个数组名称赋值给指针，那么此时对应的就是这个数组的第一个值，因为数组名所代表的就是该数组最开始的一个元素的地址

此外，如果你想引用数组的第n项，那么可以这样写：`*(a + n)`

首先我们需要理解为什么可以这么做

在C语言中，如果需要计算对应的数组的第n项的时候（例如：a[n]），会先把这个数组转换成这种格式：`*(a + n)`

也就是说：`a[n] == *(a + n)`

同理，如果加上`&`，那么就变成了这样：`&a[n] = a + n`

这与我们上文提及到的点类似：**数组名称对应该数组的第一个值的地址**

这里需要记住一个点，那就是指针是一个变量，而数组名称不是一个变量，所以，**a++是不合法的**

当我们把一个数组名称传给一个函数时，实际上是将这个数组第一个元素的地址传进函数

接下来通过一个例子来说明这个点：
``` C
int strlen(char lst[]) {
    int o;
    for (o = 0;*lst != '\0';++lst,++o) {
        ;
    }
    return o;
}
````
首先这里先把一个数组传进去，接下来是for循环，每次循环结束都将数组lst向后移动一项，直到最后一项为结束符

在每次循环中都将用于计数的`o`加一，也就是对应的数组的长度

需要注意的一个点是，在这里的函数参数中，`int strlen(char lst[])`的`lst[]`可以换成`*lst`

也可以将指向子数列起始位置的指针传递给函数，这样，就可以实现将函数的一部分传递给函数的效果：
``` C
func(&a[2])
```

当然，同理于下面的表达：
``` C
func(a + 2)
```

如果起始位置不为第一项，那么便可以在参数中使用负数

假设我们传入的数组的起始位置为第三项，那么`a[-1]`则为第二项，`a[-2]`则为第一项，`a[-3]`由于超过数组的边界，会导致报错

## 地址算术运算
接下来讲讲这部分的内容

在这里我们将实现两个新的函数功能，分别是`alloc()`和`afree()`，第一个函数的功能是返回一个指向n个连续字符存储单元的指针，而下一个函数的功能是释放已经分配好的内存空间

这里的两个函数十分重要，在标准库中有相对应的函数，分别是`malloc()`和`free()`

让我们来简单介绍一下这两个函数

首先先让我们创建一个空白的储存区，接下来我们的东西将会存放在这里，接下来我们需要知道一个点，由于我们的这两个函数所处理的对象都是指针，所以其他函数可以不用知道数组的名字

而因此，我们在声明这两个函数的时候可以使用`static`关键字使得这两个函数变为静态变量，这样的原因是防止外部函数对这两个函数进行一些操作

首先，我们命名空白储存区为：`allocbuf`，并且命名另一个变量`allocp`作为一个标志，用于判断已经使用的空间

``` C
#define ALLOCSIZE 10000
static char allocbuf[ALLOCSIZE];
static char *allocp = allocbuf; // 这里的作用是将标志设定为数组的第一项，也就是初始化标志
```

接下来看看函数`alloc`的本体

``` C
char *alloc(int n){
    if(allocbuf + ALLOCSIZE - allocp >= n){
        allocp += n;
        return allocp - n;
    }
    else{
        return 0;
    }
}
```
这里的步骤为先获取所需要的空间大小`int n`，接下来是一个喜闻乐见的判断

先看到判断条件`allocbuf + ALLOCSIZE - allocp >= n`

这里是什么意思呢？我们可以先逐步逐步分析一下

第一个运算是`allocbuf + ALLOCSIZE`，通过上文我们可以得知`allocbuf`是这个存储区的首项，而后面是一共的大小

而为什么要`- allocp`呢？不妨让我们思考一下，这里的`allocp`是什么。由上文得知，这里是已经使用的空间

那么整条表达式所要表达的便是求出剩余的空间

这里就有人要问了：诶，`allocbuf`不是第一项的内存地址16进制码吗，那要怎么运算呢？

这里可以注意到一个有意思的点，`allocp`定义为什么？

嗯对的，这里一开始定义的就是一个内存的地址，那么两个十六进制相减，得到的就是这两者的距离了，也就是还剩余的空间

可能还有疑惑说，诶，那第一次要怎么运行呢

事实上，由于第一次还没有存进去**任何的东西**，此时存储区是空白的，换句话讲，此时剩余的空间为`ALLOCSIZE`

> 这里allocbuf和allocp由于相等直接抵消掉了，等到后面allocp才会增加

那么在判断完成后，便可以执行下面的语句了

``` C
allocp += n;
```
这个语句代表占用的空间大小

``` C
return allocp - n;
```
而这个语句为什么返回的是原来的`allocp`呢？

这里我们思考一下要返回什么东西，如果说还有空余位置，那么就返回空闲位置的起始点`allocp`，如果没有，则返回0

所以这里得返回一开始的起始点

### 一个有意思的点
前文说过，`allocp`是一个内存地址，那么当超出范围后返回的是0呢？

这里需要补充一个小知识，在C语言中，0永远不是有效的数据地址，因此，我们可以将返回值0表示发生了异常情况（也就是满了）

在程序中，通常用常量NULL来代替常量0

---
接下来继续来讲下一个函数`afree()`

这个函数的主要作用是释放已经使用的空间

首先我们先看到其传入的参数：`char *p`，很明显，这是个指针

接下来看看函数内部结构：
``` C
void afree(char *p){
    if (p >= allocbuf && p < allocbuf + ALLOCSIZE){
        allocp = p;
    }
}
```
显而易见的，可以看到这里有个判断语句

那么判断的条件是什么呢？`p >= allocbuf && p < allocbuf + ALLOCSIZE`

这里有两个判断的部分，让我们看第一个部分

``` C
p >= allocbuf
```
这里看着可能有点头晕，但是没关系，先让我们理清楚p是什么，由上文可知，p是传入的参数，是一个指针

所以，这里对应的就是其指向的值的内存地址，而另一个参数就是这个存储区的第一项的内存地址

而第二个判断是在原有的基础上加上了存储区的大小，稍微思考一下可以得知，`allocbuf + ALLOCSIZE`便是存储区最右边的内存位置

总结来说，这里就是判断这个指针的内存地址是否位于存储区内，如果位于这个位置则进入下面的语句

而下面的语句也很简单，便是将指针赋值给我们的标识变量`allocp`

那么这样做会发生什么呢？

假设这个指针的地址为0x005

而`allocp`的位置是0x0A1

此时如果赋值，那么便会使`allocp`的位置变为0x005

也就是空出了一部分位置，传进函数的指针p的位置被空出来了！

这也就对应了这个函数的功能——**释放已分配好的存储空间**

## 字符指针与函数
接下来讲讲字符指针与函数

首先讲一下关于字符串常量的内容

首先我们需要知道的一点是字符串常量是一个字符数组

这一点在之前的很多方面都有使用到

---
当我们想要输出什么语句的时候常常会使用到`printf()`

例如我们一开始的例子：`printf("Hello World!\n")`

当出现这样的一个语句在程序中，实际上是使用字符指针来访问该字符串的

而在上面的例子中，语句接受的是一个指向字符数组第一个字符的指针，换句话来讲，字符串常量可以通过一个指向其第一个字符的指针访问

接下来还有其他的用法

假定我们声明了一个指针pmessage，并且将一个指向该字符数组的指针赋值给pmessage

``` C
char *pmessage;
pmessage = "hello world!";
```
那么此时这个指针指向的位置就是该字符串的位置

这里需要注意的一点是，此处与直接赋值一个数组是不同的：
``` C
char amessage[] = "hello world!";
```
为什么是不同的？

在直接声明一个数组的情况下，数组`amessage`始终指向同一个位置，而指针`pmessage`是一个指针，指向的位置是一个字符串常量，这个指针可以被修改来指向其他地址，但如果试图修改这个指针指向的字符串内容 ，那么是没有被定义的

接下来通过一个例子来说明一下这个功能

在标准库中有一个函数`strcpy(char s,char t)`

这个函数的功能是将字符串t复制给s，起到一个文本复制的功能

首先是最基本的实现：
``` C
void strcpy(char *s,char *t){
    int i;
    i = 0;
    while ((s[i] = t[i]) != '\0'){
        i++;
    }
}
```
这里的本质为指针的复制，也就是把t的地址复制给指针s，因此，并不是复制字符（虽然效果一样）

接下来是第二种实现的方式：
``` C
void strcpy(char *s,char *t){
    while ((*s = *t) != '\0'){
        s++;
        t++;
    }
}
```
这里使用到了之前提到的一个小技巧，`t + i`可以移动指针的内存地址

虽然这样看已经很简洁了，但是事实上经验丰富的程序员并不会这么写，而是选择这种格式：
``` C
void strcpy(char *s,char *t){
    while(((*s++ = *t++)!= '\0'));
}
```
利用自增运算符，可以使得整个表达更加简洁

从这里我们也可以发现，使用指针的的确确会比直接使用数组下标更加简便

---
接下来我们研究的函数是字符串比较函数：`strcmp(s,t)`

这个函数的作用是比较两个字符串的字符，其比较的准则为字典顺序

如果小于则返回负整数，如果等于则返回0，如果大于则返回正整数

返回值这里指的是s和t由前向后逐字符比较时遇到的第一个不相等字符处的差值

接下来开始复现这个函数

首先依旧是最简单的数组下标的写法：
``` C
int strcmp(char *s, char *t){
    int i;
    for (i = 0;s[i] == t[i];i++){
        if (s[i] == '\0'){
            return 0;
        }
    }
    return s[i] - t[i];
}
```
接下来开始分析这一串代码：

首先我们先从最基础的开始讲起，也就是for语句

这个for语句指的是如果比较的这两个字符是相等的则继续比较，不返回值，如果相等且刚好为终止符，则返回0（也就是相同的意思）r

那么如果不相等会怎么样呢？根据代码内容来看，如果不相等则会直接跳出循环，进入到下一个语句，也就是返回两个字符的差值

这与我们上文说过的是相同的

接下来是指针的形式：

``` C
int strcmp(char *s,char *t){
    for(; *s == *t ;s++,t++){
        if(*s == '\0'){
            return 0;
        }
    }
    return *s - *t;
}
```
这里的核心思想与上文数组的思想基本上一致

首先还是照例：指针为数组名则代表为第一项的内存地址，所以这里初始化为：`*s == *t`

每次for语句结束自动便为下一项，继续比较：`s++,t++`

如果不相等则返回差值，这里的思路是一致的

### 补充点：压入栈与弹出栈
接下来来稍微补充这一点：

在第四章实现逆波兰计算器的时候稍微提到一嘴

在学完指针后可以使用更方便的方法来实现这一操作

首先是压入栈：
``` C
*p++ = val;
```
前文也说过，这里指的是先对内存地址p进行自增

弹出栈是这个：
``` C
val = *--p;
```

## 指针数组以及指向指针的指针
接下来讲讲这方面的内容，首先我们需要明确一个点，那就是**指针也是一种变量**

而正因如此，我们便可以将指针放入数组当中，

在之前的章节中，我们有提到一个排序的例子，在那个例子里面我们实现了排序的效果

但是如果我们将排序的东西稍微调整一下，比如说把排序的东西换成长度不一的文本行，那么就没办法很好的处理了

所以我们需要用更加高效的处理方式

这里我们将引入指针来处理类似的问题

现在假设我们待排序的文本行都相邻地存储在一个常字符数组里面，那么每个文本行便可以通过指向它的第一个字符的指针来访问

并且，这些指针可以存储在一个数组里面

如此一来，我们便可以实现排序的操作：当需要交换顺序的时候，直接交换数组里面的指针位置即可

一般而言，我们会将一个程序按照功能分割成几部分（利用函数），在需要使用的时候利用main函数来分别执行即可

接下来让我们实际写一个这样的程序

### 思路部分
首先，让我们捋一捋思路

这个程序大概长这样：
``` C
输入 -> 排序 -> 输出
```
排序部分我们可以直接使用之前讲过的快速排序，那么其他的呢？

我们需要知道我们最后的结果是什么，嗯，便是把排好序的数组一个一个打印出来

那么输出部分可以使用循环和自增来解决这个问题

但是最开始的输入呢？由于我们这里使用了指针，也就说我们需要在输入的时候建立指针，为了防止出现边界溢出的问题，我们还需要统计输入的行数，如果出现溢出的现象，则直接退出

接下来让我们构思一下输入的部分

首先，我们这里使用了指针，意味着需要为输入的东西分配内存，而分配内存，我们可以使用上一节中的`alloc()`

既然有了`alloc()`，那么指针地址的事情也就顺利解决了，只要在每次输入进去的时候，将返回的内存使用大小的地址当做使用的地址即可，并且，这里既然使用了`alloc()`便要记得检查内存地址是否正确，防止出现超过边界的情况

于是我们便可以写出这样的函数
``` C
int readlines(char *lineptr[],int maxlines)
{
    int len,nlines;
    char *p,line[MAXLEN];
    nlines = 0;
    while ((len = getline(line, MAXLEN)) > 0){
        if (nlines >= maxlines || (p = alloc(len)) == NULL){
            return -1;
        }
        else{
            line[len - 1] = '\0';
            strcpy(p, line);
            lineptr[nlines++] = p;
        }
    }
    return nlines
}
```
接下来让我们细细的分析一下这串代码

首先先把里面使用到的函数讲一下：`strcpy(p, line)`指的是将`line`的内容复制给`p`，`getline(line, MAXLEN)`获取输入，`line`为接受字符的数组，而后面的第二个参数`MAXLEN`指的是数组最大的长度

之后，让我们看到第一个赋值那里：`nlines = 0`

这里的意思是把获取到的字符数量设置为0，变量`nlines`指的是目前所拥有的字符数量，这里的字符数量分割标准为每个换行符分割一次

接下来是循环语句，这里的作用是判断输入的长度是否大于零，说白了就是判断是否有输入

在循环语句里面便是一个判断语句

`nlines`之前讲过了，`maxlines`指的是最大的分割数量，`p`代表的每次分割的内存地址，此处`(p = alloc(len)) = NULL`的目的是防止内存地址错误

如果都不满足（也就是正常运行），则会进入到下面的部分

此处首先执行了这个操作`line[len - 1] = '\0';`，也就是将长度的倒数一项设置为终止符，那么倒数第一项是什么呢？

诶，我们可以思考一下我们是以什么作为分割标准的，对，就是换行符`\n`，所以，这里就是将换行符换成了终止符

换完后有什么作用呢？之前反复强调了这一点，一个字符数组必须以终止符`\n`作为结尾

所以，这里的目的其实是让每个分割的字符数组合法化

接下来是最后的`lineptr[nlines++] = p;`

前文得知，这里的`p`是一个内存地址，所以不难推断，此处的数组`lineptr[]`便是存储着每个被分割的字符数组的内存地址

在完成输入之后，接下来是输出部分：

输出部分也很简单，只需要用循环输出排列好的指针数组既可

``` C
void writelines(char *lineptr[],int nlines){
    int i;

    for(i = 0 ;i < nlines; i++){
        printf("%s\n",lineptr[i]);
    }
}
```
这里需要注意的一点就是lineptr这个数组存储的是我们所有的内存地址