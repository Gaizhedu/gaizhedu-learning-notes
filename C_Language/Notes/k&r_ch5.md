# 指针与数组

这一章将说明有关指针的内容

## 导言
首先我们先理解一下什么是指针，指针是一种保存变量地址的变量。在C语言中，指针的使用十分广泛，并且如果合理使用指针，那么会大幅度的简化操作，完成更加高效和紧凑的代码

需要注意的一点是，从ANSI C后，指针使用void\*代替char\*作为通用指针的类型

## 指针与地址
接下来开始正式介绍指针

### 内存是怎么组织的
通常来讲，机器都有一些列连续编号或者编址的存储单元，这些存储单元你可以单个进行操纵，也可以连续的成组操纵

一个字节可以存储一个`char`类型，而两个相邻的字节类型可以存储一个`short`类型的数据，而如果是相邻的四个字节存储单元可以存储一个long类型的数据

而指针是一个可以存放一个地址的一组存储单元

### 正文
在介绍内存是怎么组织的之后，便要开始讲正题了，首先先介绍一下一元运算符`&`

具体用法如下：
``` C
p = &c
```

这里把c的地址赋值给p，所以我们称p为指向C的指针，需要注意的一点是地址运算符&只能应用于内存中的对象，也就是变量和数组元素，并且不能作用于表达式、常量和寄存器变量

一元运算符*是间接寻址或者是间接引用运算符，当他作用于指针的时候，将访问指针所指向的对象

下面通过一个例子来说明这一点：
``` C
int x = 1,y = 2, z[10];

int *ip;

ip = &x;
y = *ip;
*ip = 0;
ip = &z[0];
```
在上面的例子中，我们初始化了一个指针：`ip`

这个指针的类型为整数类型

而在初始化之后，存在一个赋值的操作：`ip = &x;`，由上文可知，&的作用是找到该变量的内存地址

这里将&x的内存地址赋值给了指针`ip`，换句话讲，也就是指针`ip`指向了`x`

而下面一个表达式则为：`y = *ip;`

由于上文将指针`ip`指向了x，而x的值为1，所以这里y会被赋值为1

下面的`*ip = 0;`指的是把指针`ip`指向的值赋值为`0`，那么什么是指针指着的值呢？上面提及过为：`x`

所以，这里也就是把x的值赋值为0

另外，指针还可以指向数组中的某一位，比如最后一个表达式：`ip = &z[0];`

简单总结一下关于指针的用法

初始化指针为`类型 *指针名;`，想要把指针指向某个元素，不需要加星号，但对应的值必须为对应的地址：`指针 = &变量名`

而如果想要把指针指向的元素赋值给变量，则需要使用*：`变量 = *指针名;`

如果想要修改指针指向的值，也需要加*：`*指针名 = 新的值;`

---
另外，指针与变量一致，对应什么类型就只能指向什么类型的值，int的指针只能指向整型数，double的指针只能指向浮点数

但是有一点不同的是，**void类型的指针可以存放任何类型的指针，但不能间接引用它本身**

指针在使用的时候跟变量有些许一致的地方：

``` C
*ip = *ip + 1;
y = *ip + 1;
*ip += 1;
++*ip;
(*ip)++
```

这里可能会出现疑惑了，诶，为什么下面的后缀要加括号呢？

那是因为如果不加括号，则会先对`ip`加1运算，**而不是对指针指向的东西进行运算**，如果不加括号，那就是对地址进行运算了

这也说明了*和++运算优先级是一致的，所以遵循从右到左的顺序

指针之间是可以互相指向的，例如：

``` C
int x = 1;

int *ip,*iq;

ip = &x;

iq = ip;
```
最后的`iq = ip;`会将指针`ip`的东西赋值给`iq`，则两者指向的东西就是一致的了

## 指针与函数参数
接下来讲讲有关指针在函数参数里面的应用

依旧从之前的一个函数讲起，在之前我们使用过这个函数`swap()`用于两个数之间的互相调换位置

``` C
void swap(int x, int y){
    int temp = y;
    y = x;
    x = temp;
}
但是，这个函数有一个比较大的缺陷，例如下面这种情况：
``` C
void swap(int x,int y);

int main() {
    int a = 1,b = 2;

    swap(a,b);
    printf("%d\t%d",a,b);
}

void swap(int x,int y) {
    int temp;
    temp = x;
    x = y;
    y = temp;
}
```
很显然，在`main()`里面，我们将两个变量传入了函数里面，企图交换位置

但是实际运行的结果，发现输出的还是原来的参数

这是因为参数传递是采用传值的方式，被传入的值会创建一个副本，从而导致了只是交换副本的值，原先的值并没有发生任何变化

这也告诉我们一个点：**调用的函数是没办法直接修改主调函数中变量的值**

那要怎么办呢？诶，这里指针就可以派上用场了

我们只需要把指针的地址传给函数，即可让两个地址交换

由于打印的时候打印的是指针指向的变量的内存地址，而交换地址后指向的位置也会随之交换，这就可以完成我们的目的

``` C
void swap(int *x,int *y);

int main() {
    int a = 1,b = 2;

    swap(&a,&b);
    printf("%d\t%d",a,b);
}

void swap(int *x,int *y) {
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}
```

接下来通过一个实际的例子来说明

我们的目的是实现一个这样的函数：`getint`，使得所有输入进去的字符全部转换为整数，并且在返回的时候返回这个整数

那么我们要怎么去设计呢？

首先，按照惯例，我们需要在输入为EOF的时候停止程序，那么便可以把是否返回EOF作为标准

``` C
#define SIZE 100
int main() {
    int n ,array[SIZE];

    for (n = 0 ;n < SIZE && getint(&array[n])!= EOF;n++) {
        ;
    }
}
```
由于getint每次都会返回输入的值，所以这里便可以作为判断的条件

接下来是函数内部的表达式

首先，依旧选择跳过所有的空白符：

``` C
while (isspace(c = getch())) {
    ;// 依旧跳过空白行
}
```

