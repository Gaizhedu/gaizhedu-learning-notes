# 指针与数组

这一章将说明有关指针的内容

## 导言
首先我们先理解一下什么是指针，指针是一种保存变量地址的变量。在C语言中，指针的使用十分广泛，并且如果合理使用指针，那么会大幅度的简化操作，完成更加高效和紧凑的代码

需要注意的一点是，从ANSI C后，指针使用void\*代替char\*作为通用指针的类型

## 指针与地址
接下来开始正式介绍指针

### 内存是怎么组织的
通常来讲，机器都有一些列连续编号或者编址的存储单元，这些存储单元你可以单个进行操纵，也可以连续的成组操纵

一个字节可以存储一个`char`类型，而两个相邻的字节类型可以存储一个`short`类型的数据，而如果是相邻的四个字节存储单元可以存储一个long类型的数据

而指针是一个可以存放一个地址的一组存储单元

### 正文
在介绍内存是怎么组织的之后，便要开始讲正题了，首先先介绍一下一元运算符`&`

具体用法如下：
``` C
p = &c
```

这里把c的地址赋值给p，所以我们称p为指向C的指针，需要注意的一点是地址运算符&只能应用于内存中的对象，也就是变量和数组元素，并且不能作用于表达式、常量和寄存器变量

一元运算符*是间接寻址或者是间接引用运算符，当他作用于指针的时候，将访问指针所指向的对象

下面通过一个例子来说明这一点：
``` C
int x = 1,y = 2, z[10];

int *ip;

ip = &x;
y = *ip;
*ip = 0;
ip = &z[0];
```
在上面的例子中，我们初始化了一个指针：`ip`

这个指针的类型为整数类型

而在初始化之后，存在一个赋值的操作：`ip = &x;`，由上文可知，&的作用是找到该变量的内存地址

这里将&x的内存地址赋值给了指针`ip`，换句话讲，也就是指针`ip`指向了`x`

而下面一个表达式则为：`y = *ip;`

由于上文将指针`ip`指向了x，而x的值为1，所以这里y会被赋值为1

下面的`*ip = 0;`指的是把指针`ip`指向的值赋值为`0`，那么什么是指针指着的值呢？上面提及过为：`x`

所以，这里也就是把x的值赋值为0

另外，指针还可以指向数组中的某一位，比如最后一个表达式：`ip = &z[0];`

简单总结一下关于指针的用法

初始化指针为`类型 *指针名;`，想要把指针指向某个元素，不需要加星号，但对应的值必须为对应的地址：`指针 = &变量名`

而如果想要把指针指向的元素赋值给变量，则需要使用*：`变量 = *指针名;`

如果想要修改指针指向的值，也需要加*：`*指针名 = 新的值;`

---
另外，指针与变量一致，对应什么类型就只能指向什么类型的值，int的指针只能指向整型数，double的指针只能指向浮点数

但是有一点不同的是，**void类型的指针可以存放任何类型的指针，但不能间接引用它本身**

指针在使用的时候跟变量有些许一致的地方：

``` C
*ip = *ip + 1;
y = *ip + 1;
*ip += 1;
++*ip;
(*ip)++
```

这里可能会出现疑惑了，诶，为什么下面的后缀要加括号呢？

那是因为如果不加括号，则会先对`ip`加1运算，**而不是对指针指向的东西进行运算**，如果不加括号，那就是对地址进行运算了

这也说明了*和++运算优先级是一致的，所以遵循从右到左的顺序

指针之间是可以互相指向的，例如：

``` C
int x = 1;

int *ip,*iq;

ip = &x;

iq = ip;
```
最后的`iq = ip;`会将指针`ip`的东西赋值给`iq`，则两者指向的东西就是一致的了