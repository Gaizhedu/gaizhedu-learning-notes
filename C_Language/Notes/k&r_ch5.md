# 指针与数组

这一章将说明有关指针的内容

## 导言
首先我们先理解一下什么是指针，指针是一种保存变量地址的变量。在C语言中，指针的使用十分广泛，并且如果合理使用指针，那么会大幅度的简化操作，完成更加高效和紧凑的代码

需要注意的一点是，从ANSI C后，指针使用void\*代替char\*作为通用指针的类型

## 指针与地址
接下来开始正式介绍指针

### 内存是怎么组织的
通常来讲，机器都有一些列连续编号或者编址的存储单元，这些存储单元你可以单个进行操纵，也可以连续的成组操纵

一个字节可以存储一个`char`类型，而两个相邻的字节类型可以存储一个`short`类型的数据，而如果是相邻的四个字节存储单元可以存储一个long类型的数据

而指针是一个可以存放一个地址的一组存储单元

### 正文
在介绍内存是怎么组织的之后，便要开始讲正题了，首先先介绍一下一元运算符`&`

具体用法如下：
``` C
p = &c
```

这里把c的地址赋值给p，所以我们称p为指向C的指针，需要注意的一点是地址运算符&只能应用于内存中的对象，也就是变量和数组元素，并且不能作用于表达式、常量和寄存器变量

一元运算符*是间接寻址或者是间接引用运算符，当他作用于指针的时候，将访问指针所指向的对象

下面通过一个例子来说明这一点：
``` C
int x = 1,y = 2, z[10];

int *ip;

ip = &x;
y = *ip;
*ip = 0;
ip = &z[0];
```
在上面的例子中，我们初始化了一个指针：`ip`

这个指针的类型为整数类型

而在初始化之后，存在一个赋值的操作：`ip = &x;`，由上文可知，&的作用是找到该变量的内存地址

这里将&x的内存地址赋值给了指针`ip`，换句话讲，也就是指针`ip`指向了`x`

而下面一个表达式则为：`y = *ip;`

由于上文将指针`ip`指向了x，而x的值为1，所以这里y会被赋值为1

下面的`*ip = 0;`指的是把指针`ip`指向的值赋值为`0`，那么什么是指针指着的值呢？上面提及过为：`x`

所以，这里也就是把x的值赋值为0

另外，指针还可以指向数组中的某一位，比如最后一个表达式：`ip = &z[0];`

简单总结一下关于指针的用法

初始化指针为`类型 *指针名;`，想要把指针指向某个元素，不需要加星号，但对应的值必须为对应的地址：`指针 = &变量名`

而如果想要把指针指向的元素赋值给变量，则需要使用*：`变量 = *指针名;`

如果想要修改指针指向的值，也需要加*：`*指针名 = 新的值;`

---
另外，指针与变量一致，对应什么类型就只能指向什么类型的值，int的指针只能指向整型数，double的指针只能指向浮点数

但是有一点不同的是，**void类型的指针可以存放任何类型的指针，但不能间接引用它本身**

指针在使用的时候跟变量有些许一致的地方：

``` C
*ip = *ip + 1;
y = *ip + 1;
*ip += 1;
++*ip;
(*ip)++
```

这里可能会出现疑惑了，诶，为什么下面的后缀要加括号呢？

那是因为如果不加括号，则会先对`ip`加1运算，**而不是对指针指向的东西进行运算**，如果不加括号，那就是对地址进行运算了

这也说明了*和++运算优先级是一致的，所以遵循从右到左的顺序

指针之间是可以互相指向的，例如：

``` C
int x = 1;

int *ip,*iq;

ip = &x;

iq = ip;
```
最后的`iq = ip;`会将指针`ip`的东西赋值给`iq`，则两者指向的东西就是一致的了

## 指针与函数参数
接下来讲讲有关指针在函数参数里面的应用

依旧从之前的一个函数讲起，在之前我们使用过这个函数`swap()`用于两个数之间的互相调换位置

``` C
void swap(int x, int y){
    int temp = y;
    y = x;
    x = temp;
}
但是，这个函数有一个比较大的缺陷，例如下面这种情况：
``` C
void swap(int x,int y);

int main() {
    int a = 1,b = 2;

    swap(a,b);
    printf("%d\t%d",a,b);
}

void swap(int x,int y) {
    int temp;
    temp = x;
    x = y;
    y = temp;
}
```
很显然，在`main()`里面，我们将两个变量传入了函数里面，企图交换位置

但是实际运行的结果，发现输出的还是原来的参数

这是因为参数传递是采用传值的方式，被传入的值会创建一个副本，从而导致了只是交换副本的值，原先的值并没有发生任何变化

这也告诉我们一个点：**调用的函数是没办法直接修改主调函数中变量的值**

那要怎么办呢？诶，这里指针就可以派上用场了

我们只需要把指针的地址传给函数，即可让两个地址交换

由于打印的时候打印的是指针指向的变量的内存地址，而交换地址后指向的位置也会随之交换，这就可以完成我们的目的

``` C
void swap(int *x,int *y);

int main() {
    int a = 1,b = 2;

    swap(&a,&b);
    printf("%d\t%d",a,b);
}

void swap(int *x,int *y) {
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}
```

接下来通过一个实际的例子来说明

我们的目的是实现一个这样的函数：`getint`，使得所有输入进去的字符全部转换为整数，并且在返回的时候返回这个整数

那么我们要怎么去设计呢？

首先，按照惯例，我们需要在输入为EOF的时候停止程序，那么便可以把是否返回EOF作为标准

``` C
#define SIZE 100
int main() {
    int n ,array[SIZE];

    for (n = 0 ;n < SIZE && getint(&array[n])!= EOF;n++) {
        ;
    }
}
```
由于getint每次都会返回输入的值，所以这里便可以作为判断的条件

接下来是函数内部的表达式

首先，依旧选择跳过所有的空白符：

``` C
while (isspace(c = getch())) {
    ;// 依旧跳过空白行
}
```

接下来检测输入的内容，如果输入的内容不等于数字，或者是不符合我们需要保留的字符（+和-），则把这个符号放入暂存区，并且返回0

``` C
if (!isdigit(c) && c != EOF && c != '+' && c != '-') {
    ungetch(c);
    return 0;
}
```
这里使用到的`ungetch(c)`是之前在逆波兰计算器中使用到的存入缓存的函数，简单来讲就是把一个字符存取缓存区，在下一次调用的时候不选择获取`getchar()`里面的数字，而是选择提取缓存区里面的数字

这里就成功筛选出来剩下的我们需要的内容了，接下来就正式进入到我们的检测了

首先，我们需要检测出是否为负数，这里的方法也简单，只需要检测当前字符是否为负号即可，如果为负号，那么判断符号的变量改为负数即可

``` C
sign = (c == '-') ? -1 : 1;
```

这里的变量`sign`是检测是否为负数的变量

接下来是检测是否为加号或减号，如果为加号或者为减号则跳过该符号继续获取输入：

``` C
if (c == '+'|| c == '-') {
    c = getch();
}
```

那么至此，我们剩下的字符就全都是数字了，主要的逻辑依旧与之前一致，每读取一位数字则乘10后加数字

由于我们传入的参数是一个地址，函数的参数是一个指针，这里等价于将内存地址赋值给指针

``` C
int *ip = &array[n];
```

接下来的步骤与之前的是一致的：

``` C
for (*pn = 0 ; isdigit(c) ; c = getch()) {
    *pn = 10 * *pn + (c - '0');
}
```
这里也就是将数字逐一增加数字的过程

在完成计算数字之后，我们便要判断是否为正负数了

也就是使用到我们之前判断是否为正负数的这个变量`sign`

``` C
*pn *= sign;
```

最后返回对应的结果

完整代码如下：
``` C
#define SIZE 1000
int getch(void);
void ungetch(int c);
int nums = 0;

int getint(int *pn);


int main() {
    int n ,array[SIZE];
    for (n = 0 ;n < SIZE && getint(&array[n]) != EOF;n++) {
        ;
    }
    for (int i = 0;i < n;++i) {
        printf("%d\n",array[i]);
    }
}

int getint(int *pn) {
    int c,sign;

    while (isspace(c = getch())) {
        ;// 依旧跳过空白行
    }
    if (!isdigit(c) && c != EOF && c != '+' && c != '-') {
        ungetch(c);
        return 0;
    }
    sign = (c == '-') ? -1 : 1;// 依旧检查符号

    if (c == '+'|| c == '-') {
        c = getch();
    }
    for (*pn = 0 ; isdigit(c) ; c = getch()) {
        *pn = 10 * *pn + (c - '0');
    }
    *pn *= sign;
    if (c != EOF) {
        ungetch(c);
    }
    return c;
}

int bufp = 0;
#define BUFMAX 100
char buf[BUFMAX];

int getch() {
    return (bufp > 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) {
    if (bufp >= BUFMAX) {
        printf("ERROR:TO MANY CHAR");
    } else {
        buf[bufp++] = c;
    }
}
```

## 指针与数组
接下来讲讲指针与数组，首先我们需要明白，指针与数组关系是十分密切的，我们可以用指针来等价替换数组下标

那么为什么要这样做呢，因为一般来讲，用指针编写的程序要比用数组下标编写的程序要更快，但代价是使用指针的程序要更难理解

首先我们先理解一下一个数组在内存中是什么储存的

数组在内存中是连续存储的，比如说：
``` C
int a[] = {1,2,3,4,5,6,7};
```
假设第一项`a[0]`的地址为：0x7ffffcbd0

那么第二项`a[1]`的地址就为：0x7ffffcbd4

诶，为什么是加4而不是加1呢？其实之前也提及到了，在这里由于我们定义的是一个整数，所以占用的空间是4个字节

这也就是为什么是加4而不是加一的原因

类似的，我们可以写出这个数列的所有地址：

``` C
a[0]: 0x7ffffcbd0
a[1]: 0x7ffffcbd4
a[2]: 0x7ffffcbd8
a[3]: 0x7ffffcbdc
a[4]: 0x7ffffcbe0
a[5]: 0x7ffffcbe4
a[6]: 0x7ffffcbe8
```

---
我们不妨假设一下，我们的指针pa的赋值语句为：`pa = &a[0];`

此时指针将指向这个`a[0]`所在的位置，换句话讲就是`pa`的值为这个地址，而加上*变成指针后就变成对应地址的值了

``` C
int main() {
    int a[] = {1,2,3,4,5,6,7},*pa = a;
    printf("a[0]: %p\n此时的值：%d",pa,*pa);
}
// 输出：
// a[0]: 0x7ffffcbd0
// 此时的值：1
```

接下来，你还可以将这个值赋值给一个新的变量：
``` C
x = *pa;
```

### 指针运算
这里先简单接触一下指针运算

这里的例子依旧为之前的数列

假设我们的`指针pa`指向的是数列的第一项，那么我们可以通过指针运算来让其指向后面的项：

``` C
pa += 1;
```
此时`指针pa`指向的地址便是下一项，也就是`a[1]`。那么同理`pa + i`就是后面第i个元素

### 下标与指针运算
在上文的例子中，我们有这么一个赋值：
``` C
pa = &a[0];
```

但事实上，我们可以这样写：
``` C
pa = a;
```
如果将一个数组名称赋值给指针，那么此时对应的就是这个数组的第一个值，因为数组名所代表的就是该数组最开始的一个元素的地址

此外，如果你想引用数组的第n项，那么可以这样写：`*(a + n)`

首先我们需要理解为什么可以这么做

在C语言中，如果需要计算对应的数组的第n项的时候（例如：a[n]），会先把这个数组转换成这种格式：`*(a + n)`

也就是说：`a[n] == *(a + n)`

同理，如果加上`&`，那么就变成了这样：`&a[n] = a + n`

这与我们上文提及到的点类似：**数组名称对应该数组的第一个值的地址**

这里需要记住一个点，那就是指针是一个变量，而数组名称不是一个变量，所以，**a++是不合法的**

当我们把一个数组名称传给一个函数时，实际上是将这个数组第一个元素的地址传进函数

接下来通过一个例子来说明这个点：
``` C
int strlen(char lst[]) {
    int o;
    for (o = 0;*lst != '\0';++lst,++o) {
        ;
    }
    return o;
}
````
首先这里先把一个数组传进去，接下来是for循环，每次循环结束都将数组lst向后移动一项，直到最后一项为结束符

在每次循环中都将用于计数的`o`加一，也就是对应的数组的长度

需要注意的一个点是，在这里的函数参数中，`int strlen(char lst[])`的`lst[]`可以换成`*lst`

也可以将指向子数列起始位置的指针传递给函数，这样，就可以实现将函数的一部分传递给函数的效果：
``` C
func(&a[2])
```

当然，同理于下面的表达：
``` C
func(a + 2)
```

如果起始位置不为第一项，那么便可以在参数中使用负数

假设我们传入的数组的起始位置为第三项，那么`a[-1]`则为第二项，`a[-2]`则为第一项，`a[-3]`由于超过数组的边界，会导致报错

## 地址算术运算
接下来讲讲这部分的内容

在这里我们将实现两个新的函数功能，分别是`alloc()`和`afree()`，第一个函数的功能是返回一个指向n个连续字符存储单元的指针，而下一个函数的功能是释放已经分配好的内存空间

这里的两个函数十分重要，在标准库中有相对应的函数，分别是`malloc()`和`free()`

让我们来简单介绍一下这两个函数

首先先让我们创建一个空白的储存区，接下来我们的东西将会存放在这里，接下来我们需要知道一个点，由于我们的这两个函数所处理的对象都是指针，所以其他函数可以不用知道数组的名字

而因此，我们在声明这两个函数的时候可以使用`static`关键字使得这两个函数变为静态变量，这样的原因是防止外部函数对这两个函数进行一些操作

首先，我们命名空白储存区为：`allocbuf`，并且命名另一个变量`allocp`作为一个标志，用于判断已经使用的空间

``` C
#define ALLOCSIZE 10000
static char allocbuf[ALLOCSIZE];
static char *allocp = allocbuf; // 这里的作用是将标志设定为数组的第一项，也就是初始化标志
```

接下来看看函数`alloc`的本体

``` C
char *alloc(int n){
    if(allocbuf + ALLOCSIZE - allocp >= n){
        allocp += n;
        return allocp - n;
    }
    else{
        return 0;
    }
}
```
这里的步骤为先获取所需要的空间大小`int n`，接下来是一个喜闻乐见的判断

先看到判断条件`allocbuf + ALLOCSIZE - allocp >= n`

这里是什么意思呢？我们可以先逐步逐步分析一下

第一个运算是`allocbuf + ALLOCSIZE`，通过上文我们可以得知`allocbuf`是这个存储区的首项，而后面是一共的大小

而为什么要`- allocp`呢？不妨让我们思考一下，这里的`allocp`是什么。由上文得知，这里是已经使用的空间

那么整条表达式所要表达的便是求出剩余的空间

这里就有人要问了：诶，`allocbuf`不是第一项的内存地址16进制码吗，那要怎么运算呢？

这里可以注意到一个有意思的点，`allocp`定义为什么？

嗯对的，这里一开始定义的就是一个内存的地址，那么两个十六进制相减，得到的就是这两者的距离了，也就是还剩余的空间

可能还有疑惑说，诶，那第一次要怎么运行呢

事实上，由于第一次还没有存进去**任何的东西**，此时存储区是空白的，换句话讲，此时剩余的空间为`ALLOCSIZE`

> 这里allocbuf和allocp由于相等直接抵消掉了，等到后面allocp才会增加

那么在判断完成后，便可以执行下面的语句了

``` C
allocp += n;
```
这个语句代表占用的空间大小

``` C
return allocp - n;
```
而这个语句为什么返回的是原来的`allocp`呢？

这里我们思考一下要返回什么东西，如果说还有空余位置，那么就返回空闲位置的起始点`allocp`，如果没有，则返回0

所以这里得返回一开始的起始点

### 一个有意思的点
前文说过，`allocp`是一个内存地址，那么当超出范围后返回的是0呢？

这里需要补充一个小知识，在C语言中，0永远不是有效的数据地址，因此，我们可以将返回值0表示发生了异常情况（也就是满了）

在程序中，通常用常量NULL来代替常量0

---
接下来继续来讲下一个函数`afree()`

这个函数的主要作用是释放已经使用的空间

首先我们先看到其传入的参数：`char *p`，很明显，这是个指针

接下来看看函数内部结构：
``` C
void afree(char *p){
    if (p >= allocbuf && p < allocbuf + ALLOCSIZE){
        allocp = p;
    }
}
```
显而易见的，可以看到这里有个判断语句

那么判断的条件是什么呢？`p >= allocbuf && p < allocbuf + ALLOCSIZE`

这里有两个判断的部分，让我们看第一个部分

``` C
p >= allocbuf
```
这里看着可能有点头晕，但是没关系，先让我们理清楚p是什么，由上文可知，p是传入的参数，是一个指针

所以，这里对应的就是其指向的值的内存地址，而另一个参数就是这个存储区的第一项的内存地址

而第二个判断是在原有的基础上加上了存储区的大小，稍微思考一下可以得知，`allocbuf + ALLOCSIZE`便是存储区最右边的内存位置

总结来说，这里就是判断这个指针的内存地址是否位于存储区内，如果位于这个位置则进入下面的语句

而下面的语句也很简单，便是将指针赋值给我们的标识变量`allocp`

那么这样做会发生什么呢？

假设这个指针的地址为0x005

而`allocp`的位置是0x0A1

此时如果赋值，那么便会使`allocp`的位置变为0x005

也就是空出了一部分位置，传进函数的指针p的位置被空出来了！

这也就对应了这个函数的功能——**释放已分配好的存储空间**
