# 第四章
函数与程序结构

这一章要讲的内容为函数与程序结构，在之前的学习中，我们已经大量使用过函数，这一章将会更加详细地说明这一方面的内容

由于ANSI标准（C89）对于C的修改，现在C语言已经可以灵活处理一些情况了，比如说允许在声明函数的时候声明参数的类型，而为了使函数的声明与定义相适应，对于函数定义的语法也进行了修改

> 这里的声明参数也就是指：int getline(char s[]);中的char s[]

并且，如果参数的声明是恰当的，程序甚至可以自动对参数进行适当的强制类型转换

新的预处理器包含一组更完整的条件编译指令（一种通过宏参数创建带引号的字符串的方法），对宏扩展的过程也会更加严格

具体可以看这里 -> [补充内容](k&r_ch4_1.md)

## 函数的基本知识
接下讲讲函数的基本知识，首先我们不妨抛出一个问题

假设我们想要编写一个程序，这个程序的功能是查找输入行内存在的指定的连续的字符，那我们要如何编写这个程序呢？

接下来的这一节都将围绕这个问题展开

### 引入
让我们明白一些事情，如果我们想实现一个功能，那么很明显我们可以将这些功能全部都写到main函数里面，但是，一般而言更好的做法是将这些功能分散在一个一个的函数里面，而后需要用到那些功能就直接引用这些函数即可

这样的一个好处是如果可以避免各个参数之间相互影响，这也是函数的意义所在

### 思考
接下来让我们思考如何编写这个程序

首先主要的逻辑便是检测行中是否有这一串字符串，如果匹配的话就返回第一个字符的位置

一开始的逻辑便是建立一个循环，如果当前这个字符串符合对应字符串，则继续检测下去；如果字符串不相同，则选择结束检测，跳转到下一个字符

### 具体代码
接下来给出核心的代码：

``` C
int strindex(const char s[],const char target[]) {
    int i;

    for (i = 0;s[i] != '\0';++i) {
        int n = 0;
        for (int o = i;s[o] == target[n] && target[n] != '\0';++o,++n) {
            ;
        }
        if (target[n] == '\0') {
            return i + 1;
        }
    }
    return -1;
}
```
接下来开始分析这一块代码，其核心便是嵌套的**for循环**，第一个for循环的作用是逐个检查字符

而第二个for循环的作用是检查是否有跟目标语句相匹配的字符，如果第一个字符匹配，则继续检查下一个字符是否匹配，如果匹配则继续，如果不是则结束

这个思路有点类似于**双指针**的思路，指针A用于遍历整个数组，而指针B用于检查第一个字符相同后其他字符是否相同

这样做的好处是第一个指针永远不会被破坏，也就是说检查的顺序是不会被改变的，第一个指针永远按顺序检查，不会跳过任何一个元素

这里的**i**代表的是符合的第一个字母的位置

完整代码如下：
``` C
#define MAXLINE 1000
char s[MAXLINE];

char target[] = "ould";

int getline1(char s[],int lim);
int strindex(const char s[],const char target[]);

int main() {
   while (getline1(s,MAXLINE) > 0) {
        int n = strindex(s,target);
        if (n > 0) {
            printf("%d",n);
        }
        else {
            printf("error");
        }
   }
}

int getline1(char s[],int lim) {
    int i,c = 0;

    for (i = 0;--lim > 0 && (c = getchar()) != EOF;++i) {
        s[i] = c;
    }
    return i;
}

int strindex(const char s[],const char target[]) {
    int i;

    for (i = 0;s[i] != '\0';++i) {
        int n = 0;
        for (int o = i;s[o] == target[n] && target[n] != '\0';++o,++n) {
            ;
        }
        if (target[n] == '\0') {
            return i + 1;
        }
    }
    return -1;
}
```

### 定义函数
在上面的代码中，我们使用了函数来简化整个程序，通过一定的分割，现在程序变得更加简洁和更容易明白

接下来我们讲讲如何定义一个函数：
``` C
返回值的类型 函数名称(参数声明表)
    声明和语句
```
在一些情况下，甚至可以省略成这样：

``` C
dummy(){}
```
这个函数不执行任何的操作（因为花括号内没有任何的语句），同时不返回任何值（因为花括号内部没有任何可以返回值的语句）

并且，这个函数也没有声明返回值的类型，在这种情况下，返回的值的类型为int

---
如果想要向调用者返回值，那么只需要通过return语句即可

例如：`return 表达式;`，结果就是返回表达式

如果return后面没有跟着表达式，那么就不返回值。在一些必要的时候，表达式会加上括号（可选）

## 返回非整型值的函数
接下来讲讲返回非整型数的函数，由于之前的函数返回的类型均为整型类型，这里返回的类型为非整型值

通过之前对函数定义的结构分析可得：
``` C
返回值的类型 函数名称(参数声明表)
    声明和语句
```
如果想要返回非整型值的函数（例如`double`），只需要在前面返回值的类型这一栏写上对应的类型即可

并且，在调用函数的时候如果该函数返回的是非整型值，那么需要在调用函数中**显式声明**调用的类型

在之前的例子中一直都没有显示声明是因为之前的函数返回的值都是整型数，所以并不需要显示声明（没写默认为`int类型`）

接下来通过一个例子来说明这一点

### 例子
这一节我们要写的例子为将字符串转换为浮点数

在这之前我们已经写过一个将字符串转换为整型数的函数（`atoi`），这次写的函数为`atof`

首先让我们先思考一下，要怎么去实现这个效果

### 思路
处理浮点数的难点有一个，就是**小数点**，如果可以处理好小数点，那么一般来讲其他部分就可以很好的处理完毕

那么要怎么处理呢，有人想到了如果检测到小数点就像Python一样用`.append()`加上去不就好了

但是`.append()`是Python有的方法，C里面并没有类似的表达，所以我们就得思考另一种方法了

我们不妨思考一下怎么样可以移动小数点

对，就是使用`10的除法`，只要把一个数除以10，那么便可以将小数点向左移动一个单位，但是具体要怎么操作呢

我们可以先把除去小数点后的数字写出来，比如说1.001我们可以先写成1001，之后再除以1000即可得到我们想要的数字

那么怎么知道要除多少个呢？我们可以在遇到小数点的时候开始计数，小数点之前不计数，小数点之后计数

这样，便可以写出下面的函数

``` C
double atof(char s[]) {
    int i = 0,o = 0,power = 1;
    double t = 0;
    int sign = 1;

    for (i = 0;isspace(s[i]);++i) {
        ;
    }
    if (s[i] == '-') {
        sign = -1;
    }
    for (;s[i] != '.'&& s[i] != '\0';++i) {
        t = 10 * t + (s[i] - '0');
    }
    if (s[i] == '.') {
        ++i;
    }
    for (;s[i] != '\0';++i,++o) {
        t = 10 * t + (s[i] - '0');
        power *= 10;
    }
    return sign * t / power;
}
```

这个函数的原理正是上文所说的思路