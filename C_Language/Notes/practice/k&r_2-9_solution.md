# 练习2-9解析

## 代码实现
> 仅展示核心代码

``` C
int bitcount(unsigned x) {
    int b;

    for (b = 0; x != 0; ++b) {
        x &= (x - 1);
    }
    return b;
}
```
首先先思考，题目中的`x &= (x - 1);`是什么意思，表面上看，这是将一个数和这个数的前一个数进行按位与运算

那么这样做会怎么样呢，不妨思考一下为什么题中会讲到这个：`可以删除x中最右边值为1的一个二进制位`

假设这个数x的最后一位为1，那么由于这一位的本质为2的0次方，所以减掉1的结果为这一位变成0

此时根据按位与的运算规则，除非两个都为1时为1，否则为0

那么这样运算后，结果必定为0

如果x最后一位为0呢，此时减1会使得最近的1变成0，而在其之后的值均变成1

有人问为什么是这样？因为进位的原因，可以类比一下这个：
```
10000 - 1 = 09999
```
这样处理后，末尾的一位根据规则仍为0

接下来继续处理，由于为0，所以减一，又一个1退位

具体来讲是这样的：
```
111000 -> 110111 (x - 1)
110000(x & (x - 1)) -> 101111(x - 1)
100000(x & (x - 1)) -> 011111(x - 1)
000000(x & (x - 1))(为0，结束循环)
```
那么这里可以总结为，每次循环会消灭一个1，那么要想找有多少个1就只需统计循环运行多少次即可

这个算法被称为：**Brian Kernighan算法**