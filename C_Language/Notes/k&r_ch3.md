# 第三章
控制流

这一章主要讲控制流，一般来讲控制流语句就是用于控制各计算操作执行的次序

在之前的例子中使用了大量的控制流结构，本章将详细的介绍控制流语句

## 语句与程序块
**本节问题**
1. 什么是语句，什么是程序块
2. 如何使用这些语句和程序块，使用的时候要注意什么

### 语句
什么是语句，简单来讲就是在一个表达式后面加上分号`;`就变成了语句

例如：
``` C
x = 0;
i++;
```

这些表达式的后面加上了分号，代表这是一个语句

### 程序块
程序块指的是多个语句一起构成的复合语句，在语法上等价于单条语句

具体的用法是用花括号将这些语句括起来：

``` C
if (a > b){
    x = a + b;
    y = a * b;
}
```
**需要特别注意的一点是，如果不加花括号，那么程序只会识别最近的一条语句**

这一点于Python不一样，C语言更加严格，所以为了避免这样的事情发生，建议每一条语句都使用花括号，即使只有一条语句

并且与语句不同，用于结束程序块的右花括号后面并不需要加分号

## if-else语句
**本节问题**
1. 什么是if-else语句，特征是什么
2. 在使用的时候有什么需要注意的点

`if-else语句`常用于判断，核心功能为**非黑即白**，也就是说，如果if条件是错的，那么一定执行else语句（这里考虑的是if-else语句，不涉及else-if语句）

接下来通过例子来说明

``` C
if (a>0){
    b = 1;
}
else{
    b = 0;
}
```
接下来解释这个例子各个条件的触发方式，首先最简单的一点，当a大于0的时候，则b的值为1，反之，也就是小于**等于**0的时候，b的值为0

需要注意的一点是，如果你只是想简单判断，可以不用加`else`，说白了就是`else`可以省略

由于`if语句`只是简单测试表达式的数值，所以一些写法可以稍微的简化

``` C
if (a != 0)
```
由于判断就只有两个结果，要不为真（1），要不为假（0）

所以这里` != 0`相当于等于1

也就是可以这么写

``` C
if (a)
```

这种写法会相对比较简洁，但有些时候会导致表达模糊不清

### 配对else
在之前也说过，`else`语句是可以省略的，这就导致了在嵌套语句中一些省略`else语句`的`if语句`会出现一些匪夷所思的歧义

解决方法也很简单，只需要加上花括号即可，这也就是为什么之前说即使只有一个语句也要养成加花括号的习惯

``` C
if (n > 0)
    if (a > b)
        z = a:
    else
        z = b;
```

加上花括号是这样的格式：
``` C
if (n > 0){
    if (a > b)
        z = a;
}
else 
    z = b;
```

这里可以发现，原来`else语句`是最外层的`if语句`的，而不是里面的`if语句`，这也就是为什么说不加花括号容易引起歧义

那么具体的规则是什么呢？C语言的默认规则：`else语句`始终与“最近的、未配对的`if语句`”绑定

什么叫未配对？`if-else语句`是一块的，只有`if语句`就是未配对

## else-if语句
接下来讲讲`else-if语句`，这个语句的基本作用为弥补上面`if-else语句`的缺点——非黑即白

`else-if语句`可以进行多路判断，简单来说就是由之前的不是零就是一变成了可以有多个选择

具体的语法如下：
``` C
if (判断1){
    语句1;
}
else if(判断2){
    语句2;
}
else if(判断3){
    语句3;
}
else{
    语句4
}
```

与上面的`if-else语句`一样，这里末尾的`else`一样可以省略

接下来举个例子，我们想要判断你考试的分数是位于哪个等级

那么便可以这样写：
``` C
int check(const int x) {
    char grade;

    if (x > 90) {
        grade = 'A';
    }
    else if (x > 80) {
        grade = 'B';
    }
    else if (x > 70) {
        grade = 'C';
    }
    else {
        grade = 'D';
    }
    return grade;
}
```
接下来模拟一下输入，首先假设输入的x为90，首先进入第一个判断（x > 90），发现不符合结果，所以跳转到第二个判断（x > 80）发现结果符合，所以等级就为B

由于`else-if语句`是整块的，只要有一个判断满足便会直接退出判断，不会继续判断下去

---
接下来通过十分经典的例题来说明

题目为：用二分法求数字

二分法这里不多概述，接下来讲讲思路

首先要找到目标那个数，所以要逐步缩小区间，由于不知道到底要缩小多少次区间，所以这里得用到循环

接下来是主体部分，首先第一个就是要判断中间那个数是否大于/小于目标数，这是第一个判断

接下来第二个判断，既然第一个判断是大于/小于，那么第二个就是与之相反的

最后这两种情况都判断了，剩下的也就是等于的情况了，所以直接留给`else`

那么这时候可以思考一下循环的条件，由于首先最基本的肯定是右边边界要大于左边边界

要不要等于呢？看看循环内的条件，如果没有等于的话，最后的`else`永远都不会触发，所以这里条件要有等于

接下来就是判断条件里面的内容了

首先是第一个判断条件，这里假设为中间的数大于目标值

这里直接想可能有点抽象，不妨让我们举个实际例子：

目标值：20，最低为0，最高为100，那么中间的数就是50

接下来可以看到，我们中间的数50大于目标值20

那么请问怎么样才可以让这个中间的值逼近目标值呢

既然中间值比目标值大，如果移动左边的最小值，那么中间值就会变大

移动右边的最大值，那么中间值就会变小，因此这里要选移动最大值

要移动多少合适呢由于中间值大于目标值，也就是说中间值到最大值这段范围都大于目标值

所以这里要选择中间值吗？我们想想看，如果相等，那么就直接结束了，所以这里选的数为**中间值 - 1**

第二个也是同理

最后代码如下：
``` C
int dichotomy(int x);

int main(void) {
    printf("%d",dichotomy(7));
}

int dichotomy(int x) {

    int high = 100,low = 0;
    int count = 0;

    while (high >= low) {
        int mid = low + (high - low) / 2;

        ++count;
        if (mid > x) {
            high = mid - 1;
        }
        else if (mid < x) {
            low = mid + 1;
        }
        else {
            return count;
        }
    }
    return -1;
}
```
这里可能就有疑问了，最后面的`-1`是什么，这里我们观察一下，实现这个`-1`的情况是什么？

对，就是那个没有被覆盖的情况：**high < low**

如果你试着用断点调试，你会发现，到后面由于目标值一直大于中位数，所以左边界会一直加上去，直到不满足条件

这样还是太费时间了，有没有更好的方法呢？

有的，只需要在一开始就判断目标数是否符合条件皆可：
``` C
if (x > high || x < low) {
    return -1;
}
```

这样的话，就可以稍微优化一下

这里再次补充一点，为什么把这个判断写到这个循环里面，也就是：`(high >= low && x <= high && x >= low)`

这样看虽然没有了单独的`if语句`，但是由于每次进入循环都得判断，相较于原来的版本，每次要多2次比较，所以实际上是不太好的，这种优化称为**悲观优化**

### 补充内容：中间数计算
在上面的代码中可能会发现一个奇怪的点，就是在计算中间数的表达式似乎不太常规

也就是这里：
``` C
int mid = low + (high - low) / 2;
```

正常写是这样的：

``` C
int mid = (low + high) / 2;
```

这里可能就有人要说：“啊，这样写不就是为了炫技吗，在笔记写炫技内容合适吗？”

这里还真不是炫技，不妨我们假设一个情况，两者的数值都无限逼近int的最大值，此时正常写的版本会怎么样？

答案是**数值溢出**

而改进的版本很好的解决了这个问题

### 补充内容：语法糖
本节介绍的`else-if`语句实际上是一个`语法糖`

什么是语法糖，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。它让程序更简洁，更清晰，更符合人的直觉。

原先的话长这样：
``` C
if (){

}
else{
    if(){

    }
    else
}
```
这样的话如果数量一多，那么将会十分难以阅读

所以这也是为什么`else-if`语句是语法糖的原因