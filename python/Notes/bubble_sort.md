# 冒泡排序
冒泡排序指的是将一个无序的列表排序为一个有序的列表

基本原理为依次比较相邻的数，大的数则一点一点推到列表最后

其时间复杂度为O(n$2$)

接下来通过一个例子来讲讲冒泡排序：
``` Python
def bub(acc):
    n = len(acc) - 1
    a_list = acc
    for i in range(n):
        for o in range(n - i):
            if a_list[o] > a_list[o + 1]:
                a_list[o], a_list[o + 1] = a_list[o + 1], a_list[o]
    return a_list


ra_list = [4, 3, 5, 2, 6, 1]
print(bub(ra_list))

```

首先，我们拥有一个乱序的数列：`ra_list`，这里我们的目的是为了将这个乱序的数列排序

接下来开始分析函数`bub()`

首先第一步：获取这个列表一共有的项数：`len(acc)`（acc为传进来的列表），这里的目的是为了确定一共要排列的次数

又由于只剩最后两项的时候（比如说[2,1,3,4,5,6]），此时执行次数为4次，那么只要再执行一次即可完成排序，所以这里n的值被设定为`列表长度 - 1`

接下来是第一个`for循环`，可以看到这里的执行次数为n次，也就是上面的`列表长度 - 1`

继续看到第二个`for循环`，这里写的次数是`n - i`，诶，为什么这么写呢，这里先按下不表，继续看到后面

后面便是这个冒泡排序的核心，其原理是**当前一项比后一项大的时候，将前后两项交换位置**

判断的语句为这个：`if a_list[o] > a_list[o + 1]:`

而交换的语句为这个：`a_list[o], a_list[o + 1] = a_list[o + 1], a_list[o]`

这里判断的元素与变量`o`有关，而`o`又会随着每次循环而更新，这就实现了遍历的效果

这时候你可能会想到了，如果每次都把整个列表遍历一遍，那可太麻烦了，如果可以只遍历没有排序的就好了

诶，这时候便可以回收之前埋下的一个伏笔了：`n - i`

这里按照纸面的意思去想的话，可以看到，每次循环都会使得`n`减少一个单位（因为每多循环一次，`i`就加一）

这就导致了每次循环，第二个循环的次数都会减少一次

又因为我们排序的时候，每次都会将最大的那个数推到最外面

这样就不用去比较那些已经排序过后的情况了

实际运行情况如下（使用断点监测得出）：
```
i0o1:[3, 4, 5, 2, 6, 1]
i0o2:[3, 4, 2, 5, 6, 1]
i0o4:[3, 4, 2, 5, 1, 6]（这里跳过o3是因为5,6不满足判断标准，下面同理）
i1o0:[3, 2, 4, 5, 1, 6]
i1o3:[3, 2, 4, 1, 5, 6]
i2o0:[2, 3, 4, 1, 5, 6]
i2o2:[2, 3, 1, 4, 5, 6]
i3o1:[2, 1, 3, 4, 5, 6]
i4o0:[1, 2, 3, 4, 5, 6]
```

可以看到，这里大的数被一次一次地推到了右边，实现了排序的效果