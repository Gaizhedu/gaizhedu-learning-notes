# 函数
函数是Python中的一个重要组成部分，合理运用函数可以解决很多问题

## 函数的基本内容
为了更好的学习函数的相关内容，这里将简单介绍函数，如果已经有一部分基础，可以选择直接跳过这部分

这里就不复杂介绍函数是什么了，简单说就是一个可以重复执行的代码块

### 创建一个新的函数
如何创建一个函数，其实方法很简单，直接给出例子
``` Python
def a_function(name):
    return name
```
在上面的例子中`def`就是创建函数的语法，而后面的`a_function`就是这个函数的名字，后面括号内的`name`是这个函数的一个参数

函数内的`return`指的是把后面的`name`返回给调用这个函数的人，这个return语句可以不主动填写，这时候相当于填写了`return None`

这时候就有人要问了，这个返回给调用这个函数的人是什么意思呢？

我们简单举个例子

``` Python
def plus_fun(v1, v2):
    return v1 + v2

a = 2
b = 3
print(plus_fun(a,b))

# 输出：5
```
可以看到，变量a和变量b作为参数被传进了函数`plus_fun`里面，其中`v1`对应的是`a`，`v2`对应的是`b`

而不难发现，`print`的结果刚好是`return`后面的`v1 + v2`的结果

所以，`return`返回的结果是后面跟着的东西

而这里`print`语句中，里面使用了`plus_fun()`函数，所以`print`语句中输出的东西是这个函数返回的结果

### 向函数里面传值
我们已经学会了怎么创建一个函数，接下来要知道如何往一个函数里面传参数

这时候就有人要问了，传参数有什么用呢

举一个简单的例子：
这是一个函数，数学意义上的：
$f(x) = x^2$

这里的传参相当于那数字带入这里的x

同时也说明了函数的作用：可以重复执行的代码块，只要传入参数

说回正题，要如何向一个函数传入参数呢？

首先我们要确定能传入多少参数，这由函数后面的括号里面的值的多少决定

以上面的`plus_fun()`为例，这个函数一共有两个参数，一个为`v1` 另一个为`v2`，那么在传入的时候，就只能传入两个参数

而传入参数的方法也很简单，只需要在使用函数的时候在括号里面加上参数即可

``` Python
def a_fun(list_1, list_2):
    print("这是第一个列表：",list_1)
    print("这是第二个列表：",list_2)
    return list_1 + list_2

a = [1,2,3,4,5]
b = [6,7,8,9,10]
print(a_fun(a,b))

# 输出：这是第一个列表： [1, 2, 3, 4, 5]
# 这是第二个列表： [6, 7, 8, 9, 10]
# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

可以看到，传入值的顺序，是与函数定义是后面的参数的顺序相一致的

当然，如果你不想按顺序传入，只需要指定是哪几个值是什么即可：

``` Python
def a_fun(list_1, list_2):
    print("这是第一个列表：",list_1)
    print("这是第二个列表：",list_2)
    return list_1 + list_2

a = [1,2,3,4,5]
b = [6,7,8,9,10]
print(a_fun(list_2 = b,list_1 = a))

# 输出：这是第一个列表： [1, 2, 3, 4, 5]
# 这是第二个列表： [6, 7, 8, 9, 10]
# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
可以发现，这里是`b`先传入，但是由于已经说明了哪个值对应传入的哪几个值，所以输出的结果是不受顺序改变的

#### 默认参数值
这时候就有人要问了，如果要的值是不变的，那怎么办？

解决方法也很简单，只需要在创建函数的时候将值说明即可
``` Python
def introduct(name,age=18):
    print("学生：",name,"年龄：",age)
    return None

a = "小明"
b = "小华"

introduct(a)
introduct(b,19)

# 输出：学生： 小明 年龄： 18
# 学生： 小华 年龄： 19
```
这里可以发现，第一个小明在传入时没有填入`age`的值，但由于函数在定义时已经将`age`的值填好了，默认为18，所以不会报错

而第二个例子小华，在传入时重新给了一个值，使得原来函数定义时的值被覆写了，这也说明了在创建函数时写入的值可以被后面使用函数时改变

#### 可变参数
接下来来讲讲可变参数，也就是`*args`和`**kwargs`

*args：接收任意数量的位置参数（元组）
**kwargs：接收任意数量的关键字参数（字典）

这里简单举个例子说明

首先是`*args`

``` Python
def add_tuple(*args):
    print(args)
    return sum(args)

print(add_tuple(1,2,3,4,5))

# 输出：(1, 2, 3, 4, 5)
# 15
```
这里可以看到：使用`*args`可以同时传进多个参数（例如这里的`1,2,3,4,5`）

同时，还将原本的参数打包成了一个元组（见输出的第一条结果）

这样有什么好处呢？当你的参数数量不确定的时候，便可以直接将所有的参数全部用`*args`传进函数，让函数自己打包，使得代码更加简洁

此外，`*args`还可以统一处理传进的参数
``` Python
def a_func(*args):
    return sum(args)

a = (1,2,3,4,5)
b = (6,7,8,9,10)
print(a_func(*a,*b))

# 输出：55
```
可以看到，这里两个元组都被`*args`统一传进了函数

还有一个点就是`*args`的名字时可以改变的，比如想叫`*exp`也是可以的，**但是星号一定要保留**，但约定俗成还是统一叫做`*args`

##### 注意内容
在使用`*args`的时候还有一些注意的点：


另外一个就是在使用`*args`的时候要注意**位置**

下面直接给出例子：
``` Python
def e_fun(a,b,*args):
    return (a + sum(args)) * b

print(e_fun(7,10,1,2,3))

# 输出：130
# 也就是 [7 + (1 + 2 + 3)] * 10 = 130
```
但如果调换了位置的话（`b`与`*args`调换），由于`*args`可以接受任意数量的参数，所以这里会连带把`b`的值给打包，这就导致了缺少一个参数的值

所以，**在定义函数时，可变参数（\*arg）要放在位置参数（a, b）之后**

接下来是`**kwargs`
`**kwargs`是一个特殊的参数，作用是把传进的 **关键字参数** 打包成字典

什么关键字参数？大概长这样：
``` Python
def a_func(**kwarys):
    return kwarys

print(a_func(name="李华",age="18",height=170,weight=59))
```
这里引用函数时括号里面的`name`、`age`、`height`、`weight`就是关键字参数

上面的输出结果如下：
``` Python
{'name': '李华', 'age': '18', 'height': 170, 'weight': 59}
```
可以看到，返回的结果是一个字典

那么这个参数有什么优点呢？

优点在于其可以处理任意数量的关键字参数，不必担心传入时出现多余的参数而无法处理

与上文的`*args`一样，`**kwargs`同样支持自定义名称，只要把`**`保留皆可

另外一个用法是，可以用`**`解包一个字典

这里给出例子说明：
``` Python
def a_func(name, age):
    print(f"名字：{name}，年龄：{age}")

person = {"name" : "小明", "age" : 18}
a_func(**person)

# 输出：名字：小明，年龄：18
```
这里相当于把字典`person`解包成两个参数`name`和`age`，之后再传进函数内

##### 注意内容
与上文的`*args`一样，定义函数时若使用该可变参数同样要注意位置

这里的`*kwarys`要放到最后面

#### 返回结果与 return 语句
在Python的函数中，如果你想要返回函数的结果，可以使用`return`语句

在之前的内容中，也已经提及了大量的例子，这些例子中都包含了`return`语句

接下来来详细介绍一下：

**1.无返回值**
无返回值也就是不返回任何东西，如果没有填写`return`语句，则自动视为无返回值

举个例子：
``` Python
def a_func():
    print("Hello World!")

return_func = a_func()
print(return_func)

# 输出：Hello World!
# None
```
这里可以看到，使用`print`语句打印函数的输出结果是`None`，也就是无返回值

**2.返回单个值**
`return`可以返回很多东西，包括一个值，一条式子等都是可以的
``` Python
def a_func(a, b):
    c = a + b
    return c

def o_func(a, b):
    return a + b

a = 1
b = 2
print("第一条式子的结果是：",a_func(a, b))
print("第二条式子的结果是：",o_func(a, b))

# 输出：第一条式子的结果是： 3
# 第二条式子的结果是： 3
```

接下来是返回一个元组
``` Python
def a_func(name, age):
    return name, age

name = "李华"
age = 18
print(a_func(name, age))
print(type(a_func(name, age)))

# 输出：('李华', 18)
# <class 'tuple'>
```
可以看到，这里返回的类型为`tuple`，也就是**元组**

接下来是列表和字典：
``` Python
def l_func(a):
    return [x ** 2 for x in range(1, a)]

def d_func(name, age):
    return {
        "name" : name,
        "age" : age
    }

number = 5
name = "小明"
age = 18
print(l_func(number), type(l_func(number)))
print("名字是",d_func(name, age)["name"],"年龄是",d_func(name,age)["age"], type(d_func(name, age)))

# 输出：[1, 4, 9, 16] <class 'list'>
# 名字是 小明 年龄是 18 <class 'dict'>
```
可以看到，返回的结果分别是列表（list）以及字典（dict）

### 作用域与闭包
接下来来讲讲作用域和闭包：

**作用域**
作用域指的是程序中变量、函数和对象的可访问范围。举个鲜明的例子：假设你在自己的房间里面放一个箱子，那么只有在这个房间的人才能用这个箱子，此时便叫做**局部作用域**，但如果把这个箱子放到公共的地方，那么所有人都能用这个箱子，此时便叫做**全局作用域**

作用域一共有以下的种类：
<table>
    <thead>
        <tr>
            <th>名称</th>
            <th>变量位置</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>全局作用域（Global）</td>
            <td>位于<strong>模块顶部</strong>的变量，不在任何函数，类里面</td>
        </tr>
        <tr>
            <td>局部作用域（Local）</td>
            <td>变量位于函数内部，并且只能在该函数里面可见</td>
        </tr>
        <tr>
            <td>嵌套作用域（Enclosing）</td>
            <td>嵌套作用域的出现条件是位于嵌套函数中，此时内部函数可以访问外部函数的变量，注意这里的对象是内部函数而非外部函数</td>
        </tr>
        <tr>
            <td>内置作用域（Built-in）</td>
            <td>Python里面内置的函数或者变量</td>
        </tr>
    </tbody>
</table>

下面为每个作用域给出实例：
``` Python
a = "我位于模块最顶部，是全局作用域"

def a_func():
    b = "我是一个函数中的变量，所以位于局部作用域"
    print(b)
    def b_func():
        c = "我是一个嵌套函数中内部函数的一个变量，所以位于嵌套作用域"
        print(c)

    b_func()
    # 这里如果试图调用内部函数的变量c则会报错，因为变量c位于嵌套作用域
    # 而现在所处的位置是一个嵌套函数中的外部函数，不位于内部函数中，所以没法使用变量c

# 这里的 print 属于内置作用域，因为 print 是一个内置函数
print(a)
a_func()
```

#### 注意点
对于全局作用域而言，在当前模块（说白了就是在这个文件里面）下，你可以在任意地方访问，若位于其他模块，则需要使用`import`语句来导入该变量

对于局部作用域而言，只能在函数内部访问，并且函数结束时变量自动销毁，不可复用

对于嵌套作用域而言，有且仅有内部函数可以访问，如果需要修改外部函数的变量，可以使用`nonlocal`语句后对闭包作用域（外部函数）的变量进行修改

下面给出实例
``` Python 
def a_func():
    a = "我现在位于局部作用域"
    def b_func():
        nonlocal a
        a = "现在已使用 nonlocal 语句修改位于闭包作用域（外部函数 a_func）的变量a"
        print(a)
    print(a)
    b_func()

a_func()
```

这里额外再介绍一下Python中查找变量的规则：**LEGB规则**

L：Local
E：Enclosing
G：Global
B：Built-in

这里的L，也就是Local指的是Python先在函数内部查找变量

而E，指的是Enclosing，也就是在函数内部查找不到变量后便在外部函数里面查找

若还是找不到，那便是G，也就是Global，会在全局作用域里面查找

若以上都没有，则会在B，也就是Bulit-in，在内置作用域里面查找

这就是LEGB规则

---
**闭包**
闭包是嵌套在外部函数内部的内部函数，它的特点是在外部函数结束时，作为内部函数中的变量可以被储存起来，不会被销毁

需要注意的是，只有被闭包引用的变量才不会被销毁，而未被引用的变量是会被销毁的，同样的道理，闭包内部的变量也会随着函数的结束而被销毁，除非闭包内部还有另一个函数来引用闭包内部的变量

下面给出例子:
``` Python
def a_func():
    a = 10
    def b_func():
        print(a)
    return b_func

func = a_func()
func()
```
在这个例子中，我们可以看到内部函数`b_func`引用了外部函数`a_func`的一个变量a，此时内部函数`b_func`就形成了一个闭包

而在后边的 `return b_func` 中，这里的函数已经结束，外部函数`a_func`已经被销毁，但是由于内部函数是个闭包，导致了变量a被保存起来
这也是为什么后面`func()`可以正常输出a的值的原因

需要注意一点的是，这里内部函数在引用外部函数的变量时不需要加`nonlocal`，但是如果内部函数出现了修改变量的情况，则需要加`nonlocal`，否则内部函数会将变量认为是一个新的变量

---
## 参数（进阶）
### 位置参数与关键字参数
在之前的内容已经稍微讲过了有关位置参数和关键字参数的内容，接下来来细致介绍一下相关内容

位置参数和关键字参数都是Python中用来向函数传递参数的一种方式

首先是**位置参数**

位置参数指的是 *按照参数定义的顺序依次传递的参数*

具体的特点是：传递参数时按照定义的顺序传递，不可以调换顺序，并且不可以省略，除非有默认值

接下来给出具体例子：
``` Python
def a_func(name,age,work):
    print(f"你的名字叫做{name}，年龄为{age}，工作为{work}")

a_func("李华","28","程序员")

# 输出：你的名字叫做李华，年龄为28，工作为程序员
```
在上面这个例子中，函数 `a_func` 被引用时后面带着的三个参数就被称为位置参数，可以看到，三个参数被依次传递到函数内部

这里如果试图调换顺序，则会使得参数的位置错位：
``` Python
def a_func(name,age,work):
    print(f"你的名字叫做{name}，年龄为{age}，工作为{work}")

a_func("28","程序员","李华")

# 输出：你的名字叫做28，年龄为程序员，工作为李华
```

因此，**在使用位置参数时一定要注意参数的传入顺序**

---
接下来是**关键字参数**，正如这个参数的名字一样，关键字参数可以通过关键词来传递参数，这样的好处是当你在传递参数时，可以不考虑传递的顺序，只需要考虑关键词是否对应即可

下面给出例子：
``` Python
def a_func(name,age,work):
    print(f"你的名字叫做{name}，年龄为{age}，工作为{work}")

a_func(age = "28",work = "程序员",name = "李华")

# 输出：你的名字叫做李华，年龄为28，工作为程序员
```
可以看到，通过使用关键字参数，即使传递参数时的顺序不是定义函数时的顺序，但每个参数都被正确的传递了，这也体现了关键字参数中不依赖顺序的特点

在使用关键字参数的时候，还可以通过默认值来省略部分参数

下面照例给出例子：

``` Python
def a_func(name, work, age=20):
    print(f"你的名字叫做{name}，年龄为{age}，工作为{work}")


a_func(work="程序员", name="李华")

# 输出：你的名字叫做李华，年龄为20，工作为程序员
```

这个例子就是使用了默认值，在函数刚定义的时候将默认值声明皆可

在声明后在引用函数时便可以不导入相对应的值

#### 注意事项
在使用关键字参数的默认值时，要注意声明的时候要把默认值放到参数最后面的位置
例如：
``` Python
def a_func(name, age = 18 ,work):
    ...

def a_func(name, work, age = 18):
    ...

```
在上面两个函数中，只有第二个函数才是正确的，而第一个函数因为默认值没有放到最后而导致报错

### 默认参数的陷阱
在上面的关键字参数中，我们已经提到过默认值参数这个概念了，接下来来说说有关默认参数里面的陷阱

当默认参数是可变对象（如列表、字典、集合）时，该对象会在函数定义时被创建，并且所有调用共享同一个实例。

例如，当一个函数默认参数值是一个列表，此时如果调用函数将值加进去会导致不符合目标

``` Python
def a_func(list_v , list_a  = []):
    list_a.append(list_v)
    print(list_a)
    return None

a_func(1)
a_func(2)

# 输出：[1]
# [1, 2]
```
可以看到，在第二次输出时，并没有按照我们的要求正确输出`[2]`，而是输出了`[1,2]`
要解决这种情况也很简单，只需要将每次的列表初始化即可，下面给出修正后的例子
``` Python
def a_func(list_v , list_a  = None):
    list_a = []
    list_a.append(list_v)
    print(list_a)
    return None

a_func(1)
a_func(2)

# 输出：[1]
# [2]
```

这里其实还有一点问题，当用户主动传入一个非空列表时，如果按这里的输入，则会导致列表被重置：
``` Python
def a_func(list_v, list_a = None):
    list_a = []
    list_a.append(list_v)
    print(list_a)
    return None


list_1 = [100]
a_func(200,list_1)

# 输出：[200]
```
可以看到，这里的输出并不是我们预想的`[100, 200]`

这是因为每次调用函数`a_func`会导致列表重置一次

为了避免这种情况发生，需要在函数里面新增一个判断语句
``` Python
def a_func(list_v, list_a = None):
    if list_a is None:
        list_a = []
    list_a.append(list_v)
    print(list_a)
    return None


list_1 = [100]
a_func(200,list_1)

# 输出：[100, 200]
```
这样就成功避免了传入时原先列表非空的情况

---

另外还有就是关于默认参数的作用域问题，如果默认参数引用了外部变量，则可能导致在后面更新变量时出现变量不更新的情况
``` Python
a = 100
def a_func(a2 = a):
    print(a2)
    return None

a_func()
a = 200
a_func()

# 输出：100
# 100
```
可以看到，这里在后面更新a的值为200时，后续调用函数并没有改变结果

### 解包
接下来来讲讲解包，其实这部分的内容已经在可变参数（*args 和 **kwarys）中介绍过了，但还是详细介绍一下

首先是**位置参数解包**

当使用`*`时，你可以将一个列表或者元组拆分成多个元素，然后依次到函数的各个位置参数：

``` Python
def a_func(a1, a2, a3):
    print(f"第一个参数是{a1}，第二个参数是{a2}，第三个参数是{a3}")
    return None


list_1 = [111, 222, 333]
a_func(*list_1)

# 输出：第一个参数是111，第二个参数是222，第三个参数是333
```
从这里可以看到，列表的三个位置分别被解包为三个值，并被传到了函数里面

如果不使用解包的做法是这样的：
``` Python
def a_func(a1, a2, a3):
    print(f"第一个参数是{a1}，第二个参数是{a2}，第三个参数是{a3}")
    return None


list_1 = [111, 222, 333]
a_func(list_1[0],list_1[1],list_1[2])

# 输出：第一个参数是111，第二个参数是222，第三个参数是333
```
这里没有使用解包，而是用了传统的列表的项来向函数里面传入值，显然可读性比较低

并且如果列表的数值过多，就会导致需要传入的数值过多，大大影响了代码的可读性

---

接下来是**关键字参数解包**

关键字参数解包用于解包字典，之后将解包后的值传进函数，下面直接给出例子

``` Python
def a_func(name, age):
    print(f"名字：{name}，年龄：{age}")

person = {"name" :"李华","age":"20"}
a_func(**person)

# 输出：名字：李华。年龄：20
```
可以看到，这里`**person`将`person`这个字典解包成对应的内容

由于这里解包之后的参数为关键字参数，所以可以不用在意传入顺序，只需要确保关键字是正确的皆可

接下来是**混合解包**，说白了就是这两种解包方式可以同时使用：

``` Python
def a_func(a1, a2, a3, a4, a5):
    print(f"列表解包为：{a1}、{a2}、{a3}，字典解包为：{a4}、{a5}")
    return None


list_1 = [1, 2, 3]
dic = {"a4": 4, "a5": 5}
a_func(*list_1, **dic)

# 输出：列表解包为：1、2、3，字典解包为：4、5
```

可以看到，这里分别使用了位置参数解包以及关键字参数解包

`list_1`的三个值分别传递给`a1`，`a2`，`a3`，而字典`dic`因为为关键字参数，所以被分别传递给各自的参数

---
## 高阶函数
接下来来讲讲高阶函数，高阶函数并不是指这个函数更加高级，而是指这个函数可以接受其他函数作为参数，或者将函数当做返回值

这样的函数有很多，之后会逐一介绍

首先我们需要理解第一个高阶函数的概念：**将函数作为参数**

---
### 将函数作为参数
正如字面上的意思一致，你可以将一个函数作为一个参数，接下来将用实际例子介绍一下：
``` Python
def a_func(a1, a2):
    return a1 + a2

def b_func(a_func, b1, b2):
    return a_func(b1 , b2)

print(b_func(a_func,1,2))

# 输出：3
```
我们来逐一解释这个例子的语句：

首先先从这里看起：`print(b_func(a_func,1,2))`

这里的可以拆分成几部分，分别是：
- 负责打印的`print()`
- 负责调用函数的`b_func()`
- 以及传进去的参数`a_func,1,2`

之后我们来看一下调用的这个函数内容是什么：
``` Python
def b_func(a_func, b1, b2):
    return a_func(b1 , b2)
```
很明显，这里是这样的，返回一个以参数`a_func`的值的函数，其中这个函数传进了两个值（b1和b2）

需要注意的是，这里函数定义时的参数名`a_func`与我们导入的函数名相同纯属巧合，你可以随便更改这个函数名：
``` Python
def b_func(thisisafunc, b1, b2):
    return thisisafunc(b1 , b2)
```
而让我们重新看一下我们传入了什么：很明显是`a_func`，所以这里就是调用了函数`a_func`

接下来让我们看看`a_func`函数的内容：
``` Python
def a_func(a1, a2):
    return a1 + a2
```

很明显，这里是接受两个值：a1和a2，然后返回其相加的值

而这里的a1和a2是是什么？细心往前观察可以看到，就是我们传入的值b1和b2，而这个b1和b2又是什么？再次回看传进函数`b_func`的值可以发现，b1是1，而b2是2

由此，这里输出的值也就是3了

---
在理解完高阶函数在将函数作为参数这方面的应用后，我们可以写一个简单的四则计算器：
``` Python
def plus(p1, p2):
    return p1 + p2

def minus(mi1, mi2):
    return mi1 - mi2

def multiply(mu1, mu2):
    return mu1 * mu2

def divide(d1, d2):
    return d1 / d2

def operate(func, s1, s2):
    return func(s1, s2)

print(operate(plus,2,5))
print(operate(minus,9,2))
print(operate(multiply,5,6))
print(operate(divide,6,2))

# 输出：7
# 7
# 30
# 3.0

# 这里其实有个小问题，就是除法没有检测除数不能为0，不过就当忽略这个点了
# 当然如果要加上这个功能只需要在除法的函数那里加上一个检测d2 == 0 即可
```

---
### 返回函数
接下来来讲讲返回函数，也就是返回的结果是个函数，这是什么意思呢，直接举个例子分析一下
``` Python
def a_func(a):
    def b_func(b):
            return a * b
    return b_func

func = a_func(2)
print(func(3))

# 输出：6
```
接下来还是逐一解析语句：

首先看最主要的内容，也就是`print(func(3))`

这里很明显是往`func`里面塞一个参数`3`，诶，那`func`是什么呢？

往上看我们可以得知：哦，原来`func`代表的是将参数2传进函数`a_func`

这时候我们就已经了解到我们的操作是干什么了，接下来来实际看看函数

首先是第一个，也就是函数`a_func`：
``` Python
def a_func(a):
    def b_func(b):
            return a * b
    return b_func
```
可以看到这个函数里面还有一个函数，我们这里先不考虑，直接看到下面

可以发现返回语句返回的是一个函数，也就是`b_func`。这里需要注意一点的是，这里函数`a_func`的参数a已经被我们在一开始调用的时候传入了值（也就是2）

我们看到函数`b_func`
``` Python
def b_func(b):
        return a * b
```
可以看到，这里的函数内容是返回外部参数a和内部变量b的乘积

这里可能就有人要问了：诶，我刚才看用`return`语句调用函数的时候没有加括号传进值吗，这不是稳报错吗，你是不是写错了

我们可以回看我们一开始的`print`语句里面写了什么，也就是：`func(3)`，可以看到这里传进了一个值`3`，其实这里等价于`a_func(2)(3)`，在调用函数`a_func`后返回调用的函数`b_func`时相当于`b_func(3)`

这里可以看到传入了一个值3，也就是函数`b_func`里面的位置参数b

所以，这也就是为什么输出结果为6的原因

---
### 常见内置高阶函数
在Python中，有很多内置的高阶函数，接下来来逐一介绍
#### map()
map()函数的作用是返回一个迭代器，具体如下：`map(func, iterable)`
接下来给出例子：
``` Python
s = [1,2,3,4,5]
list_1 = map(lambda x,:x ** 2, s)
print(list(list_1))

# 输出：[1, 4, 9, 16, 25]
```
接下来来逐一解析一下这个语法

首先看一下最主要的

## 匿名函数 Lambda
Lambda的作用是创建一个一次性的简单函数，支持传入参数等操作

与普通的函数相比，匿名函数不需要`def`语句，并且即写即用。如果需要用到一些一次性的语句，便可以使用Lambda语句

接下来来详细介绍Lambda

### 语法与使用场景
Lambda的语法非常简单，主要由下面三部分组成
``` Python
lambda x, y : x * y
```
这里的`lambda`是告诉Python说下面的内容是有关匿名函数的内容，而后面的`x, y`就是这个匿名函数的位置参数，而后面的`x * y`就是匿名函数的表达式

下面给出一个实际例子：
``` Python
multiply = lambda x, y : x * y
print(multiply(1,2))

# 输出：2
```
在这个例子中，我们定义了一个匿名函数，并通过变量`multiply`引用它

当然，如果你不想用变量引用，也可以用下面这种形式：
``` Python
print((lambda x, y: x * y)(1, 2))
```
这样的话代码会比较简洁，但缺点是不能通过变量调用

使用Lambda的场景大部分是在需要使用一些简单的一次性操作中，这类场景由于语句比较简单，所以不需要使用具名函数`def`来定义函数，故使用匿名函数

### 与常规函数对比
匿名函数与具名函数的对比很明显，接下来列个表格来说明
<table>
    <thead>
        <tr>
            <th>特性</th>
            <th>匿名函数lambda</th>
            <th>具名函数def</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>定义方式</td>
            <td>使用<strong>Lambda</strong>关键字</td>
            <td>使用<strong>def</strong>关键字</td>
        <tr>
        <tr>
            <td>函数名称</td>
            <td>无函数名称（要不然为什么叫匿名函数），但仍可以用变量引用</td>
            <td>必须有名称，否则无法调用</td>
        <tr>
        <tr>
            <td>函数主体</td>
            <td>只能有一条表达式</td>
            <td>可以用多个表达式，甚至可以有其他函数</td>
        <tr>
        <tr>
            <td>返回结果</td>
            <td>自动返回</td>
            <td>用return语句，忘记加自动识别为return None</td>
        <tr>
        <tr>
            <td>适合场景</td>
            <td>简单的语句</td>
            <td>需要复杂运算（表达式多于一行）</td>
        <tr>
    </tbody>
</table>

可以看到，匿名函数与具名函数各有各的特点

接下来用一个具体的例子来说明：
``` Python
def a_func(a1, a2):
    print(f"传入的值为{a1}和{a2}")
    return a1 ** a2

print("相加的值为：",(lambda x, y:x + y)(a_func(10,2),3))

# 输出：传入的值为10和2
# 相加的值为： 103
```
可以看到在这个例子中，有多个语句的使用了具名函数，而简单计算使用了匿名函数
