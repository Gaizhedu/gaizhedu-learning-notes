# 函数
函数是Python中的一个重要组成部分，合理运用函数可以解决很多问题

## 函数的基本内容
为了更好的学习函数的相关内容，这里将简单介绍函数，如果已经有一部分基础，可以选择直接跳过这部分

这里就不复杂介绍函数是什么了，简单说就是一个可以重复执行的代码块

### 创建一个新的函数
如何创建一个函数，其实方法很简单，直接给出例子
``` Python
def a_function(name):
    return name
```
在上面的例子中`def`就是创建函数的语法，而后面的`a_function`就是这个函数的名字，后面括号内的`name`是这个函数的一个参数

函数内的`return`指的是把后面的`name`返回给调用这个函数的人，这个return语句可以不主动填写，这时候相当于填写了`return None`

这时候就有人要问了，这个返回给调用这个函数的人是什么意思呢？

我们简单举个例子

``` Python
def plus_fun(v1, v2):
    return v1 + v2

a = 2
b = 3
print(plus_fun(a,b))

# 输出：5
```
可以看到，变量a和变量b作为参数被传进了函数`plus_fun`里面，其中`v1`对应的是`a`，`v2`对应的是`b`

而不难发现，`print`的结果刚好是`return`后面的`v1 + v2`的结果

所以，`return`返回的结果是后面跟着的东西

而这里`print`语句中，里面使用了`plus_fun()`函数，所以`print`语句中输出的东西是这个函数返回的结果

### 向函数里面传值
我们已经学会了怎么创建一个函数，接下来要知道如何往一个函数里面传参数

这时候就有人要问了，传参数有什么用呢

举一个简单的例子：
这是一个函数，数学意义上的：
$f(x) = x^2$

这里的传参相当于那数字带入这里的x

同时也说明了函数的作用：可以重复执行的代码块，只要传入参数

说回正题，要如何向一个函数传入参数呢？

首先我们要确定能传入多少参数，这由函数后面的括号里面的值的多少决定

以上面的`plus_fun()`为例，这个函数一共有两个参数，一个为`v1` 另一个为`v2`，那么在传入的时候，就只能传入两个参数

而传入参数的方法也很简单，只需要在使用函数的时候在括号里面加上参数即可

``` Python
def a_fun(list_1, list_2):
    print("这是第一个列表：",list_1)
    print("这是第二个列表：",list_2)
    return list_1 + list_2

a = [1,2,3,4,5]
b = [6,7,8,9,10]
print(a_fun(a,b))

# 输出：这是第一个列表： [1, 2, 3, 4, 5]
# 这是第二个列表： [6, 7, 8, 9, 10]
# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

可以看到，传入值的顺序，是与函数定义是后面的参数的顺序相一致的

当然，如果你不想按顺序传入，只需要指定是哪几个值是什么即可：

``` Python
def a_fun(list_1, list_2):
    print("这是第一个列表：",list_1)
    print("这是第二个列表：",list_2)
    return list_1 + list_2

a = [1,2,3,4,5]
b = [6,7,8,9,10]
print(a_fun(list_2 = b,list_1 = a))

# 输出：这是第一个列表： [1, 2, 3, 4, 5]
# 这是第二个列表： [6, 7, 8, 9, 10]
# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
可以发现，这里是`b`先传入，但是由于已经说明了哪个值对应传入的哪几个值，所以输出的结果是不受顺序改变的

#### 默认参数值
这时候就有人要问了，如果要的值是不变的，那怎么办？

解决方法也很简单，只需要在创建函数的时候将值说明即可
``` Python
def introduct(name,age=18):
    print("学生：",name,"年龄：",age)
    return None

a = "小明"
b = "小华"

introduct(a)
introduct(b,19)

# 输出：学生： 小明 年龄： 18
# 学生： 小华 年龄： 19
```
这里可以发现，第一个小明在传入时没有填入`age`的值，但由于函数在定义时已经将`age`的值填好了，默认为18，所以不会报错

而第二个例子小华，在传入时重新给了一个值，使得原来函数定义时的值被覆写了，这也说明了在创建函数时写入的值可以被后面使用函数时改变

#### 可变参数
接下来来讲讲可变参数，也就是`*args`和`**kwargs`

*args：接收任意数量的位置参数（元组）
**kwargs：接收任意数量的关键字参数（字典）

这里简单举个例子说明

首先是`*args`

``` Python
def add_tuple(*args):
    print(args)
    return sum(args)

print(add_tuple(1,2,3,4,5))

# 输出：(1, 2, 3, 4, 5)
# 15
```
这里可以看到：使用`*args`可以同时传进多个参数（例如这里的`1,2,3,4,5`）

同时，还将原本的参数打包成了一个元组（见输出的第一条结果）

这样有什么好处呢？当你的参数数量不确定的时候，便可以直接将所有的参数全部用`*args`传进函数，让函数自己打包，使得代码更加简洁

此外，`*args`还可以统一处理传进的参数
``` Python
def a_func(*args):
    return sum(args)

a = (1,2,3,4,5)
b = (6,7,8,9,10)
print(a_func(*a,*b))

# 输出：55
```
可以看到，这里两个元组都被`*args`统一传进了函数

还有一个点就是`*args`的名字时可以改变的，比如想叫`*exp`也是可以的，**但是星号一定要保留**，但约定俗成还是统一叫做`*args`

##### 注意内容
在使用`*args`的时候还有一些注意的点：


另外一个就是在使用`*args`的时候要注意**位置**

下面直接给出例子：
``` Python
def e_fun(a,b,*args):
    return (a + sum(args)) * b

print(e_fun(7,10,1,2,3))

# 输出：130
# 也就是 [7 + (1 + 2 + 3)] * 10 = 130
```
但如果调换了位置的话（`b`与`*args`调换），由于`*args`可以接受任意数量的参数，所以这里会连带把`b`的值给打包，这就导致了缺少一个参数的值

所以，**在定义函数时，可变参数（\*arg）要放在位置参数（a, b）之后**

接下来是`**kwargs`
`**kwargs`是一个特殊的参数，作用是把传进的 **关键词参数** 打包成字典

什么关键词参数？大概长这样：
``` Python
def a_func(**kwarys):
    return kwarys

print(a_func(name="李华",age="18",height=170,weight=59))
```
这里引用函数时括号里面的`name`、`age`、`height`、`weight`就是关键词参数

上面的输出结果如下：
``` Python
{'name': '李华', 'age': '18', 'height': 170, 'weight': 59}
```
可以看到，返回的结果是一个字典

那么这个参数有什么优点呢？

优点在于其可以处理任意数量的关键词参数，不必担心传入时出现多余的参数而无法处理

与上文的`*args`一样，`**kwargs`同样支持自定义名称，只要把`**`保留皆可

另外一个用法是，可以用`**`解包一个字典

这里给出例子说明：
``` Python
def a_func(name, age):
    print(f"名字：{name}，年龄：{age}")

person = {"name" : "小明", "age" : 18}
a_func(**person)

# 输出：名字：小明，年龄：18
```
这里相当于把字典`person`解包成两个参数`name`和`age`，之后再传进函数内

##### 注意内容
与上文的`*args`一样，定义函数时若使用该可变参数同样要注意位置

这里的`*kwarys`要放到最后面

#### 返回结果与 return 语句
在Python的函数中，如果你想要返回函数的结果，可以使用`return`语句

在之前的内容中，也已经提及了大量的例子，这些例子中都包含了`return`语句

接下来来详细介绍一下：

**1.无返回值**
无返回值也就是不返回任何东西，如果没有填写`return`语句，则自动视为无返回值

举个例子：
``` Python
def a_func():
    print("Hello World!")

return_func = a_func()
print(return_func)

# 输出：Hello World!
# None
```
这里可以看到，使用`print`语句打印函数的输出结果是`None`，也就是无返回值

**2.返回单个值**
`return`可以返回很多东西，包括一个值，一条式子等都是可以的
``` Python
def a_func(a, b):
    c = a + b
    return c

def o_func(a, b):
    return a + b

a = 1
b = 2
print("第一条式子的结果是：",a_func(a, b))
print("第二条式子的结果是：",o_func(a, b))

# 输出：第一条式子的结果是： 3
# 第二条式子的结果是： 3
```

接下来是返回一个元组
``` Python
def a_func(name, age):
    return name, age

name = "李华"
age = 18
print(a_func(name, age))
print(type(a_func(name, age)))

# 输出：('李华', 18)
# <class 'tuple'>
```
可以看到，这里返回的类型为`tuple`，也就是**元组**

接下来是列表和字典：
``` Python
def l_func(a):
    return [x ** 2 for x in range(1, a)]

def d_func(name, age):
    return {
        "name" : name,
        "age" : age
    }

number = 5
name = "小明"
age = 18
print(l_func(number), type(l_func(number)))
print("名字是",d_func(name, age)["name"],"年龄是",d_func(name,age)["age"], type(d_func(name, age)))

# 输出：[1, 4, 9, 16] <class 'list'>
# 名字是 小明 年龄是 18 <class 'dict'>
```
可以看到，返回的结果分别是列表（list）以及字典（dict）

### 作用域与闭包
接下来来讲讲作用域和闭包：

**作用域**
作用域指的是程序中变量、函数和对象的可访问范围。举个鲜明的例子：假设你在自己的房间里面放一个箱子，那么只有在这个房间的人才能用这个箱子，此时便叫做**局部作用域**，但如果把这个箱子放到公共的地方，那么所有人都能用这个箱子，此时便叫做**全局作用域**

作用域一共有以下的种类：
<table>
    <thead>
        <tr>
            <th>名称</th>
            <th>变量位置</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>全局作用域（Global）</td>
            <td>位于<strong>模块顶部</strong>的变量，不在任何函数，类里面</td>
        </tr>
        <tr>
            <td>局部作用域（Local）</td>
            <td>变量位于函数内部，并且只能在该函数里面可见</td>
        </tr>
        <tr>
            <td>嵌套作用域（Enclosing）</td>
            <td>嵌套作用域的出现条件是位于嵌套函数中，此时内部函数可以访问外部函数的变量，注意这里的对象是内部函数而非外部函数</td>
        </tr>
        <tr>
            <td>内置作用域（Built-in）</td>
            <td>Python里面内置的函数或者变量</td>
        </tr>
    </tbody>
</table>

下面为每个作用域给出实例：
``` Python
a = "我位于模块最顶部，是全局作用域"

def a_func():
    b = "我是一个函数中的变量，所以位于局部作用域"
    print(b)
    def b_func():
        c = "我是一个嵌套函数中内部函数的一个变量，所以位于嵌套作用域"
        print(c)

    b_func()
    # 这里如果试图调用内部函数的变量c则会报错，因为变量c位于嵌套作用域
    # 而现在所处的位置是一个嵌套函数中的外部函数，不位于内部函数中，所以没法使用变量c

# 这里的 print 属于内置作用域，因为 print 是一个内置函数
print(a)
a_func()
```

#### 注意点
对于全局作用域而言，在当前模块（说白了就是在这个文件里面）下，你可以在任意地方访问，若位于其他模块，则需要使用`import`语句来导入该变量

对于局部作用域而言，只能在函数内部访问，并且函数结束时变量自动销毁，不可复用

对于嵌套作用域而言，有且仅有内部函数可以访问，如果需要修改外部函数的变量，可以使用`nonlocal`语句后对闭包作用域（外部函数）的变量进行修改

下面给出实例
``` Python 
def a_func():
    a = "我现在位于局部作用域"
    def b_func():
        nonlocal a
        a = "现在已使用 nonlocal 语句修改位于闭包作用域（外部函数 a_func）的变量a"
        print(a)
    print(a)
    b_func()

a_func()
```

这里额外再介绍一下Python中查找变量的规则：**LEGB规则**

L：Local
E：Enclosing
G：Global
B：Built-in

这里的L，也就是Local指的是Python先在函数内部查找变量

而E，指的是Enclosing，也就是在函数内部查找不到变量后便在外部函数里面查找

若还是找不到，那便是G，也就是Global，会在全局作用域里面查找

若以上都没有，则会在B，也就是Bulit-in，在内置作用域里面查找

这就是LEGB规则

---
**闭包**
闭包是嵌套在外部函数内部的内部函数，它的特点是在外部函数结束时，作为内部函数中的变量可以被储存起来，不会被销毁

需要注意的是，只有被闭包引用的变量才不会被销毁，而未被引用的变量是会被销毁的，同样的道理，闭包内部的变量也会随着函数的结束而被销毁，除非闭包内部还有另一个函数来引用闭包内部的变量

下面给出例子:
``` Python
def a_func():
    a = 10
    def b_func():
        print(a)
    return b_func

func = a_func()
func()
```
在这个例子中，我们可以看到内部函数`b_func`引用了外部函数`a_func`的一个变量a，此时内部函数`b_func`就形成了一个闭包

而在后边的 `return b_func` 中，这里的函数已经结束，外部函数`a_func`已经被销毁，但是由于内部函数是个闭包，导致了变量a被保存起来
这也是为什么后面`func()`可以正常输出a的值的原因

需要注意一点的是，这里内部函数在引用外部函数的变量时不需要加`nonlocal`，但是如果内部函数出现了修改变量的情况，则需要加`nonlocal`，否则内部函数会将变量认为是一个新的变量

## 参数（进阶）
### 位置参数与关键词参数
在之前的内容已经稍微讲过了有关位置参数和关键词参数的内容，接下来来细致介绍一下相关内容

位置参数和关键词参数都是Python中用来向函数传递参数的一种方式

首先是**位置参数**

位置参数指的是 *按照参数定义的顺序依次传递的参数*

具体的特点是：传递参数时按照定义的顺序传递，不可以调换顺序，并且不可以省略，除非有默认值

接下来给出具体例子：
``` Python
def a_func(name,age,work):
    print(f"你的名字叫做{name}，年龄为{age}，工作为{work}")

a_func("李华","28","程序员")

# 输出：你的名字叫做李华，年龄为28，工作为程序员
```
在上面这个例子中，函数 `a_func` 被引用时后面带着的三个参数就被称为位置参数，可以看到，三个参数被依次传递到函数内部

这里如果试图调换顺序，则会使得参数的位置错位：
``` Python
def a_func(name,age,work):
    print(f"你的名字叫做{name}，年龄为{age}，工作为{work}")

a_func("28","程序员","李华")

# 输出：你的名字叫做28，年龄为程序员，工作为李华
```

因此，**在使用位置参数时一定要注意参数的传入顺序**

---
接下来是**关键词参数**，正如这个参数的名字一样，关键词参数可以通过关键词来传递参数，这样的好处是当你在传递参数时，可以不考虑传递的顺序，只需要考虑关键词是否对应即可

下面给出例子：
``` Python
def a_func(name,age,work):
    print(f"你的名字叫做{name}，年龄为{age}，工作为{work}")

a_func(age = "28",work = "程序员",name = "李华")

# 输出：你的名字叫做李华，年龄为28，工作为程序员
```
可以看到，通过使用关键词参数，即使传递参数时的顺序不是定义函数时的顺序，但每个参数都被正确的传递了，这也体现了关键词参数中不依赖顺序的特点

在使用关键词参数的时候，还可以通过默认值来省略部分参数

下面照例给出例子：

``` Python
def a_func(name, work, age=20):
    print(f"你的名字叫做{name}，年龄为{age}，工作为{work}")


a_func(work="程序员", name="李华")

# 输出：你的名字叫做李华，年龄为20，工作为程序员
```

这个例子就是使用了默认值，在函数刚定义的时候将默认值声明皆可

在声明后在引用函数时便可以不导入相对应的值

#### 注意事项
在使用关键词参数的默认值时，要注意声明的时候要把默认值放到参数最后面的位置
例如：
``` Python
def a_func(name, age = 18 ,work):
    ...

def a_func(name, work, age = 18):
    ...

```
在上面两个函数中，只有第二个函数才是正确的，而第一个函数因为默认值没有放到最后而导致报错

### 默认参数的陷阱
在上面的关键词参数中，我们已经提到过默认值参数这个概念了，接下来来说说有关默认参数里面的陷阱

